---
title: 23.虚拟DOM
date: 2021-06-13 12:16
---

## 前言

前端框架React和Vue都使⽤了虚拟DOM，这个概念老是会被人提起，有些人可能在接触前端知识的时候就已经知道这些内容了，一次性渲染、优化渲染过程、减少页面更新次数等等。但是虚拟DOM为什么会出现，解决了什么问题，这些可能还是一知半解，所以还是得结合浏览器的⼯作机制对虚拟DOM进⾏⼀次分析。

## 缺陷

JS操纵DOM是会影响到整个渲染流⽔线的。另外，DOM还提供了⼀组JS接⼝⽤来遍历或者修改节点，这套接⼝包含了getElementById、removeChild、appendChild等⽅法。

那么我们在调⽤document.body.appendChild(node)往body节点上添加⼀个元素，调⽤该API之后会引发⼀系列的连锁反应。⾸先渲染引擎会将node节点添加到body节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这⼀过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵⼀发⽽动全⾝”。另外，对于DOM的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会⼤⼤降低渲染效率。因此，对于DOM的操作时刻都需要⾮常⼩⼼谨慎。

当然，对于简单的⻚⾯来说，其DOM结构还是⽐较简单的，所以以上这些操作DOM的问题并不会对⽤户体验产⽣太多影响。但是对于⼀些复杂的⻚⾯或者⽬前使⽤⾮常多的单⻚应⽤来说，其DOM结构是⾮常复杂的，⽽且还需要不断地去修改DOM树，每次操作DOM渲染引擎都需要进⾏重排、重绘或者合成等操作，因为DOM结构复杂，所⽣成的⻚⾯结构也会很复杂，对于这些复杂的⻚⾯，执⾏⼀次重排或者重绘操作都是⾮常耗时的，这就给我们带来了真正的性能问题。

所以需要有⼀种⽅式来减少JavaScript对DOM的操作，这就是虚拟DOM被发明的原因。

## 什么是虚拟DOM

在谈论什么是虚拟DOM之前，还是先来看看虚拟DOM到底要解决哪些事情。

+ 将⻚⾯改变的内容应⽤到虚拟DOM上，⽽不是直接应⽤到DOM上。

+ 变化被应⽤到虚拟DOM上时，虚拟DOM并不急着去渲染⻚⾯，⽽仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得⾮常轻了。

+ 在虚拟DOM收集到⾜够的改变时，再把这些变化⼀次性应⽤到真实的DOM上。

基于以上三点，再来看看什么是虚拟DOM。为了直观理解，参考下图：
<img :src="$withBase('/image/虚拟DOM执⾏流程.png')" alt="虚拟DOM执⾏流程" height="300"/>

结合React流程画的⼀张虚拟DOM执⾏流程图，下⾯来分析下虚拟DOM到底怎么运⾏的。

**创建阶段：** ⾸先依据JSX和基础数据创建出来虚拟DOM，它反映了真实的DOM树的结构。然后由虚拟DOM树创建出真实DOM树，真实的DOM树⽣成完后，再触发渲染流⽔线往屏幕输出⻚⾯。

**更新阶段：** 如果数据发⽣了改变，那么就需要根据新的数据创建⼀个新的虚拟DOM树；然后React⽐较两个树，找出变化的地⽅，并把变化的地⽅⼀次性更新到真实的DOM树上；最后渲染引擎更新渲染流⽔线，并⽣成新的⻚⾯。

既然聊到虚拟DOM的更新，那我们就不得不聊聊最新的React Fiber更新机制。通过上图我们知道，当有数据更新时，React会⽣成⼀个新的虚拟DOM，然后拿新的虚拟DOM和之前的虚拟DOM进⾏⽐较，这个过程会找出变化的节点，然后再将变化的节点应⽤到DOM上。

这⾥我们重点关注下⽐较过程，最开始的时候，⽐较两个虚拟DOM的过程是在⼀个递归函数⾥执⾏的，其**核⼼算法是reconciliation**。通常情况下，这个⽐较过程执⾏得很快，不过当虚拟DOM⽐较复杂的时候，执 ⾏⽐较函数就有可能占据主线程⽐较久的时间，这样就会导致其他任务的等待，造成⻚⾯卡顿。为了解决这 个问题，React团队重写了reconciliation算法，新的算法称为Fiber reconciler，之前⽼的算法称为Stack reconciler。

在前⾯《20 | async/await：使⽤同步的⽅式去写异步代码》那篇⽂章中我们介绍了协程，其实协程的另外 ⼀个称呼就是Fiber，所以在这⾥我们可以把Fiber和协程关联起来，那么所谓的Fiber reconciler相信也很 清楚了，就是在执⾏算法的过程中出让主线程，这样就解决了Stack reconciler函数占⽤时间过久的问题。 ⾄于具体的实现过程在这⾥我就不详细分析了，如果感兴趣的话，可以⾃⾏查阅相关资料进⾏学习。

了解完虚拟DOM的⼤致执⾏流程，应该也就知道为何需要虚拟DOM了。不过以上都从单纯的技术视⻆来分析虚拟DOM的，那接下来我们再从双缓存和MVC模型这两个视⻆来聊聊虚拟DOM。

1. 双缓存

在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显⽰。但是很多图形操作都很复杂且需要⼤量的运算，⽐如⼀幅完整的画⾯，可能需要计算多次才能完成，如果每次计算完⼀部分图像，就将其写⼊缓冲区，那么就会造成⼀个后果，那就是在显⽰⼀个稍微复杂点的图像的过程中，看到的⻚⾯效果可能是⼀部分⼀部分地显⽰出来，因此在刷新⻚⾯的过程中，会让⽤⼾感受到界⾯的闪烁。

⽽使⽤双缓存，可以让先将计算的中间结果存放在另⼀个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据⼀次性复制到显⽰缓冲区，这样就使得整个图像的输出⾮常稳定。

在这⾥，可以把虚拟DOM看成是DOM的⼀个buffer，和图形显⽰⼀样，它会在完成⼀次完整的操作之后，再把结果应⽤到DOM上，这样就能减少⼀些不必要的更新，同时还能保证DOM的稳定输出。

2. MVC模式

到这⾥我们了解了虚拟DOM是⼀种类似双缓存的实现。不过如果站在技术⻆度来理解虚拟缓存，依然不能全⾯理解其含义。那么接下来我们再来看看虚拟DOM在MVC模式中所扮演的⻆⾊。

在各⼤设计模式当中，MVC是⼀个⾮常重要且应⽤⼴泛的模式，因为它能将数据和视图进⾏分离，在涉及到⼀些复杂的项⽬时，能够⼤⼤减轻项⽬的耦合度，使得程序易于维护。

关于MVC的基础结构，可以先参考下图：

<img :src="$withBase('/image/MVC基础结构.png')" alt="MVC基础结构"/>

通过上图可以发现，MVC的整体结构⽐较简单，由模型、视图和控制器组成，其核⼼思想就是**将数据和视图分离**，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发⽣了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现⽅式，基于MVC⼜能衍⽣出很多其他的模式，如MVP、MVVM等，不过万变不离其宗，它们的基础⻣架都是基于MVC⽽来。

所以在分析基于React或者Vue这些前端框架时，我们需要先重点把握⼤的MVC⻣架结构，然后再重点查看通信⽅式和控制器的具体实现⽅式，这样我们就能从架构的视⻆来理解这些前端框架了。⽐如在分析React项⽬时，我们可以把React的部分看成是⼀个MVC中的视图，在项⽬中结合Redux就可以构建⼀个MVC的模型结构，如下图所⽰：

<img :src="$withBase('/image/React-Redux构建MVC模型.png')" alt="React-Redux构建MVC模型"/>

在该图中，我们可以把虚拟DOM看成是MVC的视图部分，其控制器和模型都是由Redux提供的。其具体实现过程如下：

+ 图中的控制器是⽤来监控DOM的变化，⼀旦DOM发⽣变化，控制器便会通知模型，让其更新数据；
+ 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发⽣了变化；
+ 视图接收到更新消息之后，会根据模型所提供的数据来⽣成新的虚拟DOM；
+ 新的虚拟DOM⽣成好之后，就需要与之前的虚拟DOM进⾏⽐较，找出变化的节点；
+ ⽐较出变化的节点之后，React将变化的虚拟节点应⽤到DOM上，这样就会触发DOM节点的更新；
+ DOM节点的变化⼜会触发后续⼀系列渲染流⽔线的变化，从⽽实现⻚⾯的更新

在实际⼯程项⽬中，需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架都能轻松上⼿了。



