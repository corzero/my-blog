---
title: 2.TCP/IP协议
date: 2021-01-04 10:41
---

## 前言

在衡量Web⻚⾯性能的时候有⼀个重要的指标叫**FP（First Paint）**，是指**从⻚⾯加载到⾸次开始绘制的时⻓**。这个指标直接影响了⽤户的跳出率，更快的⻚⾯响应意味着更多的PV、更⾼的参与度，以及更⾼的转化率。那什么影响FP指标呢？其中⼀个重要的因素是**⽹络加载速度**。

要想优化Web⻚⾯的加载速度，需要对⽹络有充分的了解。⽽理解⽹络的关键是要对⽹络协议有深刻的认识，不管是使⽤HTTP，还是使⽤WebSocket，它们都是基于TCP/IP的，如果对这些原理有⾜够了解，也就清楚如何去优化Web性能，或者能更轻松地定位Web问题了。

## 概念

### ISO模型

> 国际化标准组织（International Organization for Standardization，ISO）于1978年提出了一个网络体系结构，成为开放系统互联参考模型（Open System Interconnection，OSI)

<img :src="$withBase('/image/网络架构.png')" alt="网络架构.png"/>

如上图所示，分为7层，其中应用、会话、表示可以统称为应用层，从上往下越靠下越接近硬件。

+ **应用层**: 应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定应用程序的数据格式。主要的协议有：HTTP.FTP，Telent等

+ **传输层（TCP在此）**: 该层为两台主机上的应用程序提供端到端的通信。传输层有两个传输协议：TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，UDP是不可靠的或者说无连接的协议

+ **网络层（IP在此）**: 决定如何将数据从发送发路由到接收方。网络层通过综合考虑发送优先权，网络拥塞程度，服务质量以及可选路由的花费等来决定从网络中的A节点到B节点的最佳途径。即建立主机到主机的通信。

+ **数据链路层**: 控制网络层与物理层之间的通信，主要功能是保证物理线路上进行可靠的数据传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据结构的结构包，他不仅包含原始数据，还包含发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传达数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

+ **物理层**: 该层负责比特流在节点之间的传输，即负责物理传输，这一层的协议既与链路有关，也与传输的介质有关。通俗来说就是把计算机连接起来的物理手段。


### IP协议

> 是TCP/IP体系中的网络层协议。设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。

网际协议IP是TCP/IP的心脏，也是网络层中最重要的协议。IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或 UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是按顺序发送的或者没有被破坏。IP数据包中含有发送 它的主机的地址（源地址）和接收它的主机的地址（目的地址）。

高层的TCP和UDP服务在接收数据包时，通常假设包中的源地址是有效的。也可以这样说，IP地址形成了许多服务的认证基础，这些服务相信数据包是从一个有效的主机发送来的。IP确认包含一个选项，叫作IP source routing，可以用来指定一条源地址和目的地址之间的直接路径。对于一些TCP和UDP的服务来说，使用了该选项的IP包好像是从路径上的最后一个系统传递过来的，而不是来自于它的真实地点。这个选项是为了测试而存在的，说明了它可以被用来欺骗系统来进行平常是被禁止的连接。那么，许多依靠IP源地址 做确认的服务将产生问题并且会被非法入侵。


### TCP协议

> 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，所谓的字节流服务（Byte Stream
Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP
协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。


TCP主要特点：

1. TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接，在传送数据完毕后，必须释放已经建立的TCP连接，在传送数据完毕后，必须释放已经连接的TCP连接。

2. 每一条TCP连接只能有两个端点，即点对点的。

3. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。

4. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。

5. 面向字节流。TCP中的“流”指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但是TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。



#### 三次握手手🤝（高频面试题🐶）

> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

"客户端：喂，服务端吗？ 在不在？我要跟你说一件事。"
+ **第一次握手**：建立连接。客户端发送连接请求报文段，并将syn(标记位)设置为1，Squence Number(数据包序号)(seq)为x，接下来等待服务端确认，客户端进入SYN_SENT状态(请求连接)；


"服务端：诶，客户端 我在，你说吧。"
+ **第二次握手**：服务端收到客户端的 SYN 报文段，对 SYN 报文段进行确认，设置 ack(确认号)为 x+1(即seq+1 ; 同时自己还要发送 SYN 请求信息，将 SYN 设置为1， seq为 y。服务端将上述所有信息放到 SYN+ACK 报文段中，一并发送给客户端，此时服务端进入 SYN_RECV状态。


"客户端：好的，事情是XXXXXXXXX..."
+ **第三次握手**：客户端收到服务端的 SYN+ACK(确认符) 报文段；然后将 ACK 设置为 y+1，向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED(连接成功)状态，完成TCP 的三次握手。


#### 四次挥手手🙋🙋‍♂️（高频面试题🐶）

>因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了。但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

"客户端：喂，我要挂了"
+ **第一次挥手**：客户端发送一个 FIN(结束)，用来关闭客户到服务端的连接。 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。


"服务端：诶，好的，我想想我还有没有什么东西没跟你说的。"
+ **第二次挥手**：服务端收到这个 FIN，他发回一个 ACK(确认)，确认收到序号为收到序号+1，和 SYN 一样，一个 FIN 将占用一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP 服务器 通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。


"服务端：好像没有了....那就先这样吧。"
+ **第三次挥手**：服务端发送一个 FIN(结束)到客户端，服务端关闭客户端的连接。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

"客户端：ok，拜拜～"
+ **第四次挥手**：客户端发送 ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态


### UDP协议（拓展）

>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。

UDP主要特点：

1. UDP是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可以释放），因此减少了开销和发送数据之前的时延。

2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有很多参数）。

3. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长 的报文，UDP就照样发送，即一次发送一个报文。

3. UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。但是不使用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。

4. UDP支持一对一、一对多、多对一和多对多的交互通信。

5. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部还要短。


**两者区别**

+ TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。

+ TCP 保证数据正确性，UDP 可能丢包，TCP 保证数据顺序，UDP 不保证。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付 Tcp 通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

+ TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。

+ TCP 是面向字节流，UDP 面向报文，UDP 具有较好的实时性，工作效率比 TCP 高.并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。

+ TCP 对系统资源要求较多，UDP 对系统资源要求较少。

+ TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。

















