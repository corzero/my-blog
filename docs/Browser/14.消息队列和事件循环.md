---
title: 14.消息队列和事件循环
date: 2020-05-29
---

## 前言

首先这篇文章非常重要，在面试和很多框架中都有这个知识点的使用和优化，特别是在面试过程中，经常会问到这两个知识点，但是很多同学都是在背诵概念，实战或者上机时就懵逼了。死记硬背是不行的，所以还是希望多深刻理解这些知识点，因为事件循环⾮常底层且⾮常重要，学会它能让我们理解⻚⾯到底是如何运⾏的。

## 单线程处理任务

我们经常听人说，JS 是单线程的，那么单线程在处理任务的时候是什么样子呢？先别着急，我们先自己设计一个用来处理js任务的逻辑吧，先看下面的内容：
```js
// 在⼀个线程中去执⾏任务，我们会这样编写代码：
let a = 1;
let b = 2 * a;
console.log(b)
```

在上⾯的执⾏代码中，我们把所有任务代码按照顺序写进主线程⾥，等线程执⾏时，这些任务会按照顺序在线程中依次被执⾏；等所有任务执⾏完成之后，线程会⾃动退出。那么按照顺序就是：

1. 定义a并赋值为1
2. 定义b并赋值为2*a的结果
3. 打印b的值

按照过程来讲似乎这样的正确的，但这里就会有一个新的问题，**在线程运⾏过程中如何处理新任务？？？**

但并不是所有的任务都是在执⾏之前统⼀安排好的，⼤部分情况下，新的任务是在线程运⾏过程中产⽣的。⽐如在线程执⾏过程中，⼜接收到了⼀个新的任务，那上⾯那种⽅式就⽆法处理这种情况了。

这样的方式似乎无法满足新任务的运行，而且每次在有任务的时候开启线程去执行任务，任务结束后又关闭线程。频繁的开启/关闭线程对操作系统也是一种消耗，那么我们换个方向，能不能保持一个线程持续运行，任务执行完成后不关闭，新的任务来的时候等待当前线程上的任务结束后在运行？如果有多个新任务来了怎么办，我们可能需要去存储这些新的任务对吧。那么我们使用队列去存储这些任务，然后线程上任务完成后检查队列是否有任务，然后依次去出任务执行。其实我们之为**事件循环机制。**

按照上述想法我们更改了以往的执行机制：
+ **引⼊了循环机制**，具体实现⽅式是在线程语句最后添加了⼀个for循环语句，线程会⼀直循环执⾏。
+ **引⼊了事件**，可以在线程运⾏过程中，等待其他线程传来的事件，等待过程中线程处于暂停状态，⼀旦接收到新的任务，那么等线程上的任务完成后就会执行队列扽内容。

## 处理其他线程发送过来的任务

看看其他线程是如何发送消息给渲染主线程的，参考下图：


<img :src="$withBase('/image/主线程的消息队列.png')" alt="主线程的消息队列"  height='400'/>

从上图可以看出，渲染主线程会频繁接收到来⾃于IO线程的⼀些任务，接收到这些任务之后，渲染进程就需要着⼿处理，⽐如接收到资源加载完成的消息后，渲染进程就要着⼿进⾏DOM解析了；接收到⿏标点击的消息后，渲染主线程就要开始执⾏相应的JS脚本来处理该点击事件。

⼀个线程模型，能让其能够接收其他线程发送的消息呢？就是刚刚我们说的队列

<img :src="$withBase('/image/消息队列.png')" alt="消息队列" />  

**消息队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。**

有了队列之后，我们就可以继续改造线程模型了，改造⽅案如下图所⽰：

<img :src="$withBase('/image/线程模型.png')" alt="线程模型"  height='400'/>  

从上图可以看出，我们的改造可以分为下⾯三个步骤：

1. 添加⼀个消息队列
2. IO线程中产⽣的新任务添加进消息队列尾部
3. 渲染主线程会循环地从消息队列头部中读取任务，执⾏任务

## 处理其他进程发送过来的任务

通过使⽤消息队列，我们实现了线程之间的消息通信。在Chrome中，跨进程之间的任务也是频繁发⽣的，那么如何处理其他进程发送过来的任务？你可以参考下图：

<img :src="$withBase('/image/跨进程通信.png')" alt="跨进程通信"  height='400'/>

从图中可以看出，渲染进程专⻔有⼀个IO线程⽤来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前⾯讲解的“处理其他线程发送的任务”⼀样了，这⾥就不再重复了。

### 消息队列中的任务类型

现在你知道⻚⾯主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。参考下Chromium的[官⽅源码](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/public/platform/task_type.h)，这⾥⾯包含了很多内部消息类型，如输⼊事件（⿏标滚动、点击、移动）、微任务、⽂件读写、WebSocket、JS定时器等等。

除此之外，消息队列中还包含了很多与⻚⾯相关的事件，如JS执⾏、解析DOM、样式计算、布局计算、CSS动画等。

以上这些事件都是在主线程中执⾏的，所以在编写Web应⽤时，你还需要衡量这些事件所占⽤的时⻓，并想
办法解决单个任务占⽤主线程过久的问题。

### 如何安全退出

当⻚⾯主线程执⾏完成之后，⼜该如何保证⻚⾯主线程能够安全退出呢？Chrome是这样解决的，确定要退出当前⻚⾯时，⻚⾯主线程会设置⼀个退出标志的变量，在每次执⾏完⼀个任务时，判断是否有设置退出标志。


## ⻚⾯使⽤单线程的缺点

⻚⾯线程所有执⾏的任务都来⾃于消息队列。消息队列是“先进先出”的属性，也就是说放⼊队列中的任务，需要等待前⾯的任务被执⾏完，才会被执⾏。鉴于这个属性，就会有一些问题随之而来。

### 1. 如何处理⾼优先级的任务。


⽐如⼀个典型的场景是监控DOM节点的变化情况（节点的插⼊、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。⼀个通⽤的设计的是，利⽤JS设计⼀套监听接⼝，当变化发⽣时，渲染引擎同步调⽤这些接⼝，这是⼀个典型的观察者模式。

不过这个模式有个问题，因为DOM变化⾮常频繁，如果每次发⽣变化的时候，都直接调⽤相应的JS接⼝，那么这个**当前的任务执⾏时间会被拉⻓，从⽽导致执⾏效率的下降**。

如果将这些DOM变化做成异步的消息事件，添加到消息队列的尾部，那么⼜会影响到监控的实时性，因为在添加到消息队列的过程中，可能前⾯就有很多任务在排队了。

这也就是说，**如果DOM发⽣变化，采⽤同步通知的⽅式，会影响当前任务的执⾏效率；如果采⽤异步⽅式，⼜会影响到监控的实时性**。

**那该如何权衡效率和实时性呢？**

针对这种情况，微任务就应⽤⽽⽣了，下⾯我们来看看微任务是如何权衡效率和实时性的。

通常我们把**消息队列中的任务称为宏任务，每个宏任务中都包含了⼀个微任务队列**，在执⾏宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执⾏，因此也就解决了执⾏效率的问题。

等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执⾏下⼀个宏任务，⽽是执⾏当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。


### 2. 如何解决单个任务执⾏时⻓过久的问题

因为所有的任务都是在单线程中执⾏的，所以每次只能执⾏⼀个任务，⽽其他任务就都处于等待状态。如果其中⼀个任务执⾏时间过久，那么下⼀个任务就要等待很⻓时间。可以参考下图：

<img :src="$withBase('/image/任务执行过久.png')" alt="任务执行过久" />

从图中你可以看到，如果在执⾏动画过程中，其中有个JS任务因执⾏时间过久，占⽤了动画单帧的时间，这样会给⽤户制造了卡顿的感觉，这当然是极不好的⽤户体验。针对这种情况，JS可以通过回调功能来规避这种问题，也就是让要执⾏的JS任务滞后执⾏。

## 扩展

我们刚刚讲到关于浏览器的循环机制，那么如何在浏览器中观察每次任务呢？我们可以通过控制台的`Performance`面板监控事件的执行，类似页面加载，如下：

<img :src="$withBase('/image/页面加载性能分析.png')" alt="页面加载性能分析" height="400"/>  

从图中可以看出，我们点击展开了Main这个项⽬，其记录了主线程执⾏过程中的所有任务。图中灰⾊的就是⼀个个任务，每个任务下⾯还有⼦任务，其中的Parse HTML任务，是把HTML解析为DOM的任务。值得注意的是，在执⾏Parse HTML的时候，如果遇到JS脚本，那么会暂停当前的HTML解析⽽去执⾏JS脚本。






