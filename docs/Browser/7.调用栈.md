---
title: 7.调用栈
date: 2020-05-29
---

## 为什么JS代码会出现栈溢出？

其实在执⾏JS之前就进⾏编译并创建执⾏上下⽂。⼀般说来，有这么三种情况：
1. 当JS执⾏全局代码的时候，会编译全局代码并创建全局执⾏上下⽂，⽽且在整个⻚⾯的⽣存周期内，全局执⾏上下⽂只有⼀份。
2. 当调⽤⼀个函数的时候，函数体内的代码会被编译，并创建函数执⾏上下⽂，⼀般情况下，函数执⾏结束之后，创建的函数执⾏上下⽂会被销毁。
3. 当使⽤eval函数的时候，eval的代码也会被编译，并创建执⾏上下⽂。

好了，⼜进⼀步理解了执⾏上下⽂，了解调⽤栈⾄少有以下三点好处：

1. 了解JS引擎背后的⼯作原理；
2. 有调试JS代码的能⼒；
3. 搞定⾯试，因为⾯试过程中，调⽤栈也是出境率⾮常⾼的题⽬。

<img :src="$withBase('/image/调用栈错误.png')" alt="调用栈错误" height="200"/>   


那为什么会出现这种错误呢？这就涉及到了调⽤栈的内容。应该知道JS中有很多函数，经常会出现在⼀个函数中调⽤另外⼀个函数的情况，调⽤栈就是⽤来管理函数调⽤关系的⼀种数据结构。因此要讲清楚调⽤栈，还要先弄明⽩函数调⽤和栈结构。  

### 什么是函数调⽤   
函数调⽤就是运⾏⼀个函数，具体使⽤⽅式是使⽤函数名称跟着⼀对⼩括号。看题回答函数调⽤的过程：

```js
function add(){
var b = 10
 return a + b
}
add()
```

在执⾏到函数add()之前，JS引擎会为上⾯这段代码创建全局执⾏上下⽂，包含了声明的函数和变量，参考下图：

<img :src="$withBase('/image/全局执⾏上下⽂.png')" alt="全局执⾏上下⽂" height="300"/>   

从图中可以看出，代码中**全局变量和函数**都保存在全局上下⽂的变量环境中。

执⾏上下⽂准备好之后，便开始执⾏全局代码，当执⾏到add这⼉时，JS判断这是⼀个函数调⽤，那么将执⾏以下操作：

+ ⾸先，从全局执⾏上下⽂中，取出 add 函数代码。
+ 其次，对 add 函数的这段代码进⾏编译，并创建该函数的执⾏上下⽂和可执⾏代码。
+ 最后，执⾏代码，输出结果。

完整流程可以参考下图：

<img :src="$withBase('/image/函数调⽤过程.png')" alt="函数调⽤过程" height="400"/>  

就这样，当执⾏到add函数的时候，我们就有了两个执⾏上下⽂了：**全局执⾏上下⽂和add函数的执⾏上下⽂。**

也就是说在执⾏JS时，可能会存在多个执⾏上下⽂，那么JS引擎是如何管理这些执⾏上下⽂的呢？

答案是通过⼀种叫**栈**的数据结构来管理的。那什么是栈呢？它⼜是如何管理这些执⾏上下⽂呢？

### 什么是栈？

<img :src="$withBase('/image/栈.png')" alt="栈" height="400"/> 

想象叠盘子，先放在最下面的，最后才能拿到，满足先入后出特点的数据结构，叫 **栈**

### 什么是JS的调⽤栈？

JS引擎正是利⽤栈的这种结构来管理执⾏上下⽂的。在执⾏上下⽂创建好后，JS引擎会将执⾏上下⽂压⼊栈中，通常把这种⽤来管理执⾏上下⽂的栈称为**执⾏上下⽂栈**，⼜称**调⽤栈**。

通过复杂的代码理解上述概念：

```js 
var a = 2
function add(b, c){
    return b + c
}
function addAll(b, c){
    var d = 10
    result = add(b, c)
    return a + result + d
}
addAll(3,6)
```

1. 创建全局上下⽂，并将其压⼊栈底

<img :src="$withBase('/image/调用栈顺序1.png')" alt="调用栈顺序1" height="400"/>   

从图中你也可以看出，变量a、函数add和addAll都保存到了全局上下⽂的变量环境对象中。全局执⾏上下⽂压⼊到调⽤栈后，JS引擎便开始执⾏全局代码了。⾸先会执⾏a=2的赋值操作，执⾏该语句会将全局上下⽂变量环境中a的值设置为2。设置后的全局上下⽂的状态如下图所⽰：

<img :src="$withBase('/image/调用栈顺序2.png')" alt="调用栈顺序1" height="200"/>   

2. 调⽤addAll函数

接下来，第⼆步是调⽤addAll函数。当调⽤该函数时，JS引擎会编译该函数，并为其创建⼀个执⾏上下⽂，最后还将该函数的执⾏上下⽂压⼊栈中，如下图所⽰：

<img :src="$withBase('/image/调用栈顺序3.png')" alt="调用栈顺序2" height="400"/>   

addAll函数的执⾏上下⽂创建好之后，便进⼊了函数代码的执⾏阶段了，这⾥先执⾏的是d=10的赋值操
作，执⾏语句会将addAll函数执⾏上下⽂中的d由undefined变成了10。

3. 当执⾏到add函数调⽤语句时，同样会为其创建执⾏上下⽂，并将其压⼊调⽤栈。


<img :src="$withBase('/image/调用栈顺序4.png')" alt="调用栈顺序3" height="400"/>   


当add函数返回时，该函数的执⾏上下⽂就会从栈顶弹出，并将result的值设置为add函数的返回值，也就
是9。如下图所⽰
<img :src="$withBase('/image/调用栈顺序5.png')" alt="调用栈顺序3" height="400"/>   


4. 紧接着addAll执⾏最后⼀个相加操作后并返回，addAll的执⾏上下⽂也会从栈顶部弹出，此时调⽤栈中就只
剩下全局上下⽂了。最终如下图所⽰

<img :src="$withBase('/image/调用栈顺序5.png')" alt="调用栈顺序3" height="400"/>  

### 调⽤栈是JS引擎追踪函数执⾏的⼀个机制

还是这段代码，我们看一下如何在浏览器中调试

```js
function add(){
// 在你想要的地方debugger或者打上断点
debugger
var b = 10
 return a + b
}
add()
```

<img :src="$withBase('/image/调用栈调试.png')" alt="调用栈调试" height="400"/>

说明：
    1: 就是你所打印的断点，会在这里停顿。
    2: 第一个蓝色按钮是跳过当前断点，第二个按钮是继续下一步执行代码
    3: 你所看到的当前代码的调用栈

### 溢出？

编写代码的时候，可能会遇到以下报错：

<img :src="$withBase('/image/栈溢出.png')" alt="栈溢出" height="400"/>

这普遍是在使用递归的时候导致的错误，原因是因为**调⽤栈是有⼤⼩的**（调用栈大小主要按照当前硬件内存大小和系统所分配给浏览器的大小决定），当⼊栈的执⾏上下⽂超过⼀定数⽬，JS引擎就会报错，我们把这种错误叫
做**栈溢出**。

所以当我们使用递归的时候，需要注意边界问题，不要让他溢出，或者使用尾递归和动态规划的方式去解决问题。


### 总结

+ 每调⽤⼀个函数，JS引擎会创建执⾏上下⽂，并把该执⾏上下⽂压⼊调⽤栈，然后JS引擎开始执⾏函数代码。
+ 如果在⼀个函数A中调⽤了另外⼀个函数B，那么JS引擎会为B函数创建执⾏上下⽂，并将B函数的执⾏上下⽂压⼊栈顶。
+ 当前函数执⾏完毕后，JS引擎会将该函数的执⾏上下⽂弹出栈。
+ 当分配的调⽤栈空间被占满时，会引发“堆栈溢出”问题。