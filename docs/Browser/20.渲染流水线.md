---
title: 20.渲染流水线
date: 2020-05-29
---

## 前言
上一篇的内容中我们讲述DOM的⽣成过程，并结合具体例⼦分析了JS是如何阻塞DOM⽣成的。那本⽂我们就继续深⼊聊聊渲染流⽔线中的CSS。因为CSS是⻚⾯中⾮常重要的资源，它决定了⻚⾯最
终显⽰出来的效果，并影响着⽤户对整个⽹站的第⼀体验。所以，搞清楚浏览器中的CSS是怎么⼯作的很有必要，只有理解了CSS是如何⼯作的，你才能更加深刻地理解如何去优化⻚⾯。

## 渲染流⽔线视⻆下的CSS

先看看之前写的这个html

```css
/* theme.css */
div { color:blue }
```

```html
<html>
    <head>
        <style src='theme.css'></style>
    </head>
    <body>
        <div>1</div>
            <script>
            let div1 = document.getElementsByTagName('div')[0]
            div1.innerText = 'hello word'
            </script>
        <div>test</div>
    </body>
</html>
```
这两段代码分别由CSS⽂件和HTML⽂件构成，分析下打开这段HTML⽂件时的渲染流⽔线，先参考下⾯这张渲染流⽔线⽰意图：

<img :src="$withBase('/image/含有css页面渲染流程.png')" alt="含有css页面渲染流程" height="300"/>

⾸先是发起主⻚⾯的请求，这个发起请求⽅可能是渲染进程，也有可能是浏览器进程，发起的请求被送到⽹络进程中去执⾏。⽹络进程接收到返回的HTML数据之后，将其发送给渲染进程，渲染进程会解析HTML数据并构建DOM。这⾥你需要特别注意下，请求HTML数据和构建DOM中间有⼀段空闲时间，这个空闲时间有可能成为⻚⾯渲染的瓶颈。

当渲染进程接收HTML⽂件字节流时，会先开启⼀个**预解析线程**，如果遇到JS⽂件或者CSS⽂件，那么预解析线程会提前下载这些数据。对于上⾯的代码，预解析线程会解析出来⼀个外部的theme.css⽂件，并发起theme.css的下载。这⾥也有⼀个空闲时间需要你注意⼀下，就是在DOM构建结束之后、theme.css⽂件还未下载完成的这段时间内，渲染流⽔线⽆事可做，因为下⼀步是合成布局树，⽽合成布局树需要CSSOM和DOM，所以这⾥需要等待CSS加载结束并解析成CSSOM。

**那渲染流⽔线为什么需要CSSOM呢？**

和HTML⼀样，渲染引擎也是⽆法直接理解CSS⽂件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是CSSOM。和DOM⼀样，CSSOM也具有两个作⽤，第⼀个是提供给JS操作样式表的能⼒，第⼆个是为布局树的合成提供基础的样式信息。这个CSSOM体现在DOM中就是document.

等DOM和CSSOM都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制DOM树的结构，不同之处在于DOM树中那些不需要显⽰的元素会被过滤掉，如display:none属性的元素、head标签、script标签等。复制好基本的布局树结构之后，渲染引擎会为对应的DOM元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的⼏何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进⾏后续的绘制操作了。

这就是在渲染过程中涉及到CSS的⼀些主要流程。了解了这些之后，我们再来看看稍微复杂⼀点的场景，还是看下⾯这段HTML代码：

```css
/* theme.css */
div{
    color : coral;
    background-color:black
}
```

```html
<html>
    <head>
        <link href="theme.css" rel="stylesheet">
    </head>
    <body>
        <div>hello world</div>
        console.log('hello world')
        <div>hello world</div>
    </body>
</html>

```
<img :src="$withBase('/image/含有js和css的渲染流水线.png')" alt="含有js和css的渲染流水线" />

那我们就结合这张图来分析含有外部CSS⽂件和JS代码的⻚⾯渲染流⽔线，在解析DOM的过程中，如果遇到了JS脚本，那么需要先暂停DOM解析去执⾏JS，因为JS有可能会修改当前状态下的DOM。
不过在执⾏JS脚本之前，如果⻚⾯中包含了外部CSS⽂件的引⽤，或者通过style标签内置了CSS内容，那么渲染引擎还需要将这些内容转换为CSSOM，因为JS有修改CSSOM的能⼒，所以在执⾏JS之前，还需要依赖CSSOM。也就是说CSS在部分情况下也会阻塞DOM的⽣成。


再来看看更加复杂⼀点的情况，如果在body中被包含的是JS外部引⽤⽂件，Demo代码如下所
⽰：

```css
/* theme.css */
div {
    color : coral;
    background-color:black
}

```
```js
// test
console.log('hello world')
```

```html
<html>
    <head>
        <link href="theme.css" rel="stylesheet">
    </head>
    <body>
        <div>hello world</div>
        <script src='test.js'></script>
        <div>hello world</div>
    </body>
</html>

```
从上⾯代码可以看出来，HTML⽂件中包含了CSS的外部引⽤和JS外部⽂件，那它们的渲染流⽔线是怎样的呢？可参考下图：

<img :src="$withBase('/image/含有js和css的渲染流水线2.png')" alt="含有js和css的渲染流水线2" />

从图中可以看出来，在接收到HTML数据之后的预解析过程中，HTML预解析器识别出来了有CSS⽂件和JS⽂件需要下载，然后就同时发起这两个⽂件的下载请求，需要注意的是，这两个⽂件的下载过程是重叠的，所以下载时间按照最久的那个⽂件来算。

后⾯的流⽔线就和前⾯是⼀样的了，不管CSS⽂件和JS⽂件谁先到达，都要先等到CSS⽂件下载完成并⽣成CSSOM，然后再执⾏JS脚本，最后再继续构建DOM，构建布局树，绘制⻚⾯。

**影响⻚⾯展⽰的因素以及优化策略**
前⾯我们为什么要花这么多⽂字来分析渲染流⽔线呢？主要原因就是**渲染流⽔线影响到了⾸次⻚⾯展⽰的速度，⽽⾸次⻚⾯展⽰的速度⼜直接影响到了⽤户体验**，所以我们分析渲染流⽔线的⽬的就是为了找出⼀些影响到⾸屏展⽰的因素，然后再基于这些因素做⼀些针对性的调整。

从发起URL请求开始，到⾸次显⽰⻚⾯的内容，在视觉上经历的三个阶段。

1. 第⼀个阶段，等请求发出去之后，到提交数据阶段，这时⻚⾯展⽰出来的还是之前⻚⾯的内容。

2. 第⼆个阶段，提交数据之后渲染进程会创建⼀个空⽩⻚⾯，我们通常把这段时间称为解析⽩屏，并等待CSS⽂件和JS⽂件的加载完成，⽣成CSSOM和DOM，然后合成布局树，最后还要经过⼀系列的步骤准备⾸次渲染。

3. 第三个阶段，等⾸次渲染完成之后，就开始进⼊完整⻚⾯的⽣成阶段了，然后⻚⾯会⼀点点被绘制出来。

影响第⼀个阶段的因素主要是⽹络或者是服务器处理这块⼉，前⾯⽂章中我们已经讲过了，这⾥我们就不再继续分析了。⾄于第三个阶段，我们会在后续⽂章中分析，所以这⾥也不做介绍了。

现在我们重点关注第⼆个阶段，这个阶段的主要问题是⽩屏时间，如果⽩屏时间过久，就会影响到⽤户体验。为了缩短⽩屏时间，我们来挨个分析这个阶段的主要任务，包括了解析HTML、下载CSS、下载JS、⽣成CSSOM、执⾏JS、⽣成布局树、绘制⻚⾯⼀系列操作。

通常情况下的瓶颈主要体现在**下载CSS⽂件、下载JS⽂件和执⾏JS。**


## 优化

**所以要想缩短⽩屏时⻓，可以有以下策略：**

+ 通过内联JS、内联CSS来移除这两种类型的⽂件下载，这样获取到HTML⽂件之后就可以直接开
始渲染流程了。

+ 并不是所有的场合都适合内联，那么还可以尽量减少⽂件⼤⼩，⽐如通过webpack等⼯具移除⼀些不
必要的注释，并压缩JS⽂件。

+ 将⼀些不需要在解析HTML阶段使⽤的JS标记上sync或者defer。对于⼤的CSS⽂件，可以通过媒体查询属性，将其拆分为多个不同⽤途的CSS⽂件，这样只有在特定的场景下才会加载特定的CSS⽂件。

通过以上策略就能缩短⽩屏展⽰的时⻓了，不过在实际项⽬中，总是存在各种各样的情况，这些策略并不能随⼼所欲地去引⽤，所以还需要结合实际情况来调整最佳⽅案。



