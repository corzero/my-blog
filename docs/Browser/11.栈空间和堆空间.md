---
title: 11.栈空间和堆空间
date: 2020-05-29
---

# 前言

对于前端开发者来说， JS 的内存机制是⼀个不被经常提及的概念 ，因此很容易被忽视。特别是⼀些⾮计算机专业的同学，对内存机制可能没有⾮常清晰的认识，甚⾄有些同学根本就不知道 JS 的内存机制是什么。

但是如果你想成为⾏业专家，并打造⾼性能前端应⽤，那么你就必须要搞清楚** JS 的内存机制**了。

## JS是什么类型的语⾔？

每种编程语⾔都具有内建的数据类型，但它们的数据类型常有不同之处，使⽤⽅式也很不⼀样，⽐如C语⾔在定义变量之前，就需要确定变量的类型，你可以看下⾯这段C代码：
```js
int main(){
    int a = 1;
    char* b = "阿巴阿巴";
    bool c = true;
    c = a;
    return 0;
}
```

上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使⽤之前就需要确认其变量数据类型的称为**静态语⾔**。

相反地，我们把在运⾏过程中需要检查数据类型的语⾔称为动态语⾔。⽐如我们所讲的 JS 就是**动态语⾔**，因为在声明变量之前并不需要确认其数据类型。

前⾯代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执⾏的，因为在赋值过程中，C编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为**隐式类型转换**。⽽**⽀持隐式类型转换的语⾔称为弱类型语⾔，不⽀持隐式类型转换的语⾔称为强类型语⾔**。在这点上，C 和 JS 都是弱类型语⾔。

<img :src="$withBase('/image/栈和堆.png')" alt="栈和堆" height="400"/>  

## JS的数据类型

 JS 是⼀种弱类型的、动态的语⾔ 这句话包含了两个特点：

+ 弱类型：不需要告诉 JS 引擎这个或那个变量是什么数据类型， JS 引擎在运⾏代码的时候⾃⼰会计算出来。

+ 动态： 可以使⽤同⼀个变量保存不同类型的数据。

而 JS 的数据类型我们都知道，分两种：**原始类型和引⽤类型**

|  类型   | 描述  |
|  ----  | ----  |
| NUll  | 只有一个值 null |
| Boolean  | 只有true或false |
| Undefined  | 一个没有被赋值的变量默认是undefined，变量提升时的默认值也是undefined |
| Number  | 基于IEEE 754 标准双进度64韦二进制的值，范围在-2^63 - 1 ~ 2^63 -1 |
| String  | 文本数据，区别于C语言，js的字符串是无法更改的 |
| Symbol  | f符号类型具有唯一性，且不可修改 |
| BigInt  | 新的数字类型，可以表示任意精度的整数，即使超过Number精度也是安全的 |
| Object  | 一组属性的集合 |

**注意*：
+ 使⽤ `typeof` 检测 `Null` 类型时，返回的是 `Object`。这是当初 JS 语⾔的⼀个 Bug，⼀直保留⾄今，之所以⼀直没修改过来，主要是为了兼容⽼的代码。
+ Object类型⽐较特殊，它是由上述7种类型组成的⼀个包含了 `key-value` 对的数据类型。
+ 原始类型和引⽤类型在内存中的存储是不同的。


## 内存空间

要理解 JS 在运⾏过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。下⾯是JS的内存模型：

<img :src="$withBase('/image/内存模型.png')" alt="内存模型" height="400"/>  

在 JS 的执⾏过程中， 主要有三种类型内存空间，分别是**代码空间、栈空间和堆空间**。


## 栈空间和堆空间

这⾥的栈空间就是我们之前反复提及的调⽤栈，是⽤来存储执⾏上下⽂的。为了搞清楚栈空间是如何存储数据的，我们还是先看下⾯这段代码：

```js
function foo(){
    var a = "阿巴阿巴"
    var b = a
    var c = { name: "阿巴阿巴" }
    var d = c
}

foo()
```

当执⾏⼀段代码时，需要先编译，并创建执⾏上下⽂，然后再按照顺序执⾏代码。那么下⾯我们来看看，当执⾏到第3⾏代码时，其调⽤栈的状态，你可以参考下⾯这张调⽤栈状态图：

<img :src="$withBase('/image/调用栈状况.png')" alt="调用栈状况" height="400"/>  

当执⾏到第3⾏时，变量a和变量b的值都被保存在执⾏上下⽂中，⽽执⾏上下⽂⼜被压⼊到栈中，所以你也可以认为变量a和变量b的值都是存放在栈中的。

接下来继续执⾏第4⾏代码，由于 JS 引擎判断右边的值是⼀个引⽤类型，这时候处理的情况就不⼀样了， JS 引擎并不是直接将该对象存放到变量环境中，⽽是将它分配到堆空间⾥⾯，分配后该对象会有⼀个在“堆”中的地址，然后再将该数据的地址写进c的变量值，最终分配好内存的⽰意图如下所⽰：

<img :src="$withBase('/image/调用栈与堆空间关系.png')" alt="调用栈与堆空间关系" height="400"/>  

对象类型是存放在堆空间的，在栈空间中只是保留了对象的引⽤地址，当 JS 需要访问该数据的时候，是通过栈中的引⽤地址来访问的，相当于多了⼀道转⼿流程，这就说明两点：
+ **原始类型的数据值都是直接保存在“栈”中的，引⽤类型的值是存放在“堆”中**
+ **JS的原始类型的赋值会完整复制变量值，⽽引⽤类型的赋值是复制引⽤地址**

### 为什么不能一起存储呢？

是因为 JS 引擎需要⽤栈来维护程序执⾏期间上下⽂的状态，如果栈空间⼤了话，所有的数据都存放在栈空间⾥⾯，那么会影响到上下⽂切换的效率，进⽽⼜影响到整个程序的执⾏效率。⽐如⽂中的foo函数执⾏结束了， JS 引擎需要离开当前的执⾏上下⽂，只需要将指针下移到上个执⾏上下⽂的地址就可以了，foo函数执⾏上下⽂栈区空间全部回收，具体过程你可以参考下图：

<img :src="$withBase('/image/调用栈切换上下文.png')" alt="调用栈切换上下文" height="400"/>  

所以通常情况下，栈空间都不会设置太⼤，主要⽤来存放⼀些原始类型的⼩数据。⽽引⽤类型的数据占⽤的空间都⽐较⼤，所以这⼀类数据会被存放到堆中，堆空间很⼤，能存放很多⼤的数据，不过缺点是分配内存和回收内存都会占⽤⼀定的时间。