---
title: 3.HTTP(S)请求流程
date: 2020-05-27
---

## 前言

在上一篇文章中了解了TCP/IP协议，包括建立连接和断开连接的过程。虽然TCP连接很麻烦，但保证了安全稳定的数据传输。而HTTP(S)正是建立在TCP之上，HTTP是⼀种允许浏览器向服务器获取资源的协议，是Web的基础，通常由浏览器发起请求，⽤来获取不同类型的⽂件，例如HTML⽂件、CSS⽂件、JavaScript⽂件、图⽚、视频等。同时，HTTP也是浏览器使⽤最⼴的协议，所以要想学好浏览器，就要先深⼊了解HTTP。

## 问题

+ 有时候打开一个新的网站，一开始很慢，但是第二次第三次之后打开就很快显示呢？
+ 我们登陆一个网站后，关闭网页再打开，发现不需要在登录，就可以看到之前的登录后的状态呢？

带着这两个问题，我们往下看

## 浏览器发起请求

1. **构建请求**：⾸先，浏览器构建请求⾏信息，构建好后，浏览器准备发起⽹络请求。
```js
    GET /index.html HTTP1.1
```
<br />

2. **查找缓存**：在真正发起⽹络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的⽂件。浏览器缓存是⼀种在本地保存资源副本，下次请求时直接使⽤的技术。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，⽽不会再去源服务器重新下载。相比直接请求：
    + 缓解服务器端压⼒，提升性能（获取资源的耗时更短了）。
    + 对于⽹站来说，缓存是实现快速资源加载的重要组成部分。  

<br />

3. **查找IP地址和端⼝**: 在了解这个知识之前，还是需要梳理一下HTTP和TCP的关系，因为浏览器是使用HTTP作为应用层协议，⽤来封装请求的⽂本信息；并使⽤TCP/IP作传输层协议将它发到⽹络上，所以在HTTP⼯作开始之前，浏览器需要通过TCP与服务器建⽴连接。也就是说HTTP的内容是通过TCP的传输数据阶段来实现的，你可以结合下图更好地理解这⼆者的关系。

<img :src="$withBase('/image/TCP与HTTP关系.png')" alt="TCP与HTTP关系"/>

看完上图，大概知道在建立HTTP的时候我们需要创建一个TCP连接，建⽴TCP连接的第⼀步就是需要准备IP地址和端⼝号，那怎么获取IP地址和端⼝号？别着急啊老铁，在上篇文章中提到的DNS（Domain Name System：域名系统），就是在这里用到的。而DNS服务一般是由本地运营商提供查询的，流程如下：
    
<img :src="$withBase('/image/dns解析.jpeg')" alt="dns解析"/>

<font color=red size=3>*注意</font>：现代浏览器和操作系统其实在你第一次访问某个网站时已经缓存了当前域名对应的IP，即DNS缓存。但对应的缓存时间有所不同，现代浏览器目前是60s，操作系统中，Win是一天，而Mac OS遵循[TTL](https://baike.baidu.com/item/TTL/130248)，所以目前优先级是先检查浏览器DNS缓存，没有才检查本地系统的DNS缓存，再没有才会请求DNS服务器。


<br />

4. **等待TCP队列**： Chrome有个机制，<font color=red size=3>同⼀个域名同时最多只能建⽴6个TCP连接</font>，如果在同⼀个域名下同时有10个请求发⽣，那么其中4个请求会进⼊排队等待状态，直⾄进⾏中的请求完成。

<br />

5. **建⽴TCP连接**: 排队等待结束之后，终于可以快乐地和服务器握⼿了，在HTTP⼯作开始之前，浏览器通过TCP与服务器建⽴连接。

<br />

6. **发送HTTP请求**: ⼀旦建⽴了TCP连接，浏览器就可以和服务器进⾏通信了。⽽HTTP中的数据正是在这个通信过程中传输的。下面的图我会标注主要字段含义：

<img :src="$withBase('/image/http-header.png')" alt="http-header"/>

⾸先浏览器会向服务器发送请求⾏，它包括了**请求⽅法(Request Method)、请求URI（Request URL）和 HTTP版本协议(Version Agreement，点击Response Headers-> view source)**。 

发送请求⾏，就是告诉服务器浏览器需要什么资源，最常⽤的请求⽅法是Get。⽐如，直接在浏览器地址栏 键⼊百度的域名（www.baidu.com），这就是告诉服务器要Get它的⾸⻚资源。 

另外⼀个常⽤的请求⽅法是**POST**，它⽤于发送⼀些数据给服务器，⽐如登录⼀个⽹站，就需要通过**POST**⽅法把用户信息发送给服务器。如果使⽤**POST**⽅法，那么浏览器还要准备数据给服务器，这⾥准备的数据 是通过请求体来发送。 

在浏览器发送请求⾏命令之后，还要以请求头形式发送其他⼀些信息，把浏览器的⼀些基础信息告诉服务器。⽐如包含了浏览器所使⽤的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的Cookie、自定义头部信息等等。

## 服务端处理HTTP请求流程

1. **返回请求**：服务器处理结束后便可以返回数据给浏览器了，上图中可看到**Response Headers**,服务器也会随同响应向浏览器发送响应头。响应头包含了服务器⾃⾝的⼀些信息，⽐如服务器⽣成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客⼾端保存的Cookie等信息。点击最上方的**Response**，即可看到返回的内容。

<br />

2. **断开连接**: 通常情况下，⼀旦服务器向客⼾端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在头部加入`Connection：Keep-Alive`，那么TCP连接在发送后将仍然**保持打开状态，这样浏览器就可以继续通过同⼀个TCP连接发送请求**。保持TCP连接可以省去下次请求时需要建⽴连接的时间，提升资源加载速度。⽐如，⼀个Web⻚⾯中内嵌的图⽚就都来⾃同⼀个Web站点，如果初始化了⼀个持久连接，你就可以复⽤该连接，以请求其他资源，⽽不需要重新再建⽴新的TCP连接。

<br />

3. **重定向**(经常被人忽略)： 部分网站在访问时会出现重定向的现象，其中的响应⾏返回状态码是301，状态301就是告诉浏览器，需要重定向到另外⼀个⽹址，⽽需要重定向的⽹址正是包含在响应头的`Location`字段中，接下来，浏览器获取`Location`字段中的地址，并使⽤该地址重新导航，这就是⼀个完整重定向的执⾏流程。


## 问题解答

**二次访问新网页会变快呢？**

<img :src="$withBase('/image/访问缓存.png')" alt="访问缓存" height="500"/>

从上图的第⼀次请求可以看出，当服务器返回HTTP响应头给浏览器时，浏览器是通过响应头中的**CacheControl**字段来设置是否缓存该资源。通常，我们还需要为这个资源设置⼀个缓存过期时⻓，⽽这个时⻓是通过**Cache-Control中的Max-age**参数来设置的，⽐如上图设置的缓存过期时间是**2000秒**。

也就是说，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存（**from disk or memory**）的资源给浏览器（**code为200**）。但如果缓存过期了，浏览器则会继续发起⽹络请求。移步查看[HTTP缓存机制]()

简要来说，很多⽹站第⼆次访问能够秒开，是因为这些⽹站把很多资源都缓存在了本地，浏览器缓存直接使⽤本地副本来回应请求，⽽不会产⽣真实的⽹络请求，从⽽节省了时间。同时，DNS数据也被浏览器缓存了，这⼜省去了DNS查询环节。

**如何保持登录状态**

+ ⽤⼾打开登录⻚⾯，在登录框⾥填⼊⽤⼾名和密码，点击确定按钮。点击按钮会触发⻚⾯脚本⽣成⽤⼾登录信息，然后调⽤POST⽅法提交⽤⼾登录信息给服务器。

+ 服务器接收到浏览器提交的信息之后，查询后台，验证⽤⼾登录信息是否正确，如果正确的话，会⽣成⼀段表⽰⽤⼾⾝份的字符串，并把该字符串写到响应头的Set-Cookie字段⾥，然后把响应头发送给浏览器。

+ 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头⾥含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地(控制台>Application>Cookie)。

+ 当⽤⼾再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的Cookie数据，并把数据写进请求头⾥的Cookie字段⾥，然后浏览器再将请求头发送给服务器。

+ 服务器在收到HTTP请求头数据之后，就会查找请求头⾥⾯的“Cookie”字段信息，当查找到包
含UID=xxx的信息时，服务器查询后台，并判断该⽤⼾是已登录状态，然后⽣成含有该⽤⼾信息的⻚⾯数据，并把⽣成的数据发送给浏览器。


