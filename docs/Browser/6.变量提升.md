---
title: 6.变量提升
date: 2021-03-16 11:20
---

## 前言

其实变量提升的问题可以不需要讲的，主要还是在于几个重要概念，记住就可以。 但是我发现，很多人还是无法将变量提升的打印结果的题目做对，所以还是需要讲解一下。


## JS代码是按顺序执⾏的吗？

其实在面对变量提升的问题时，本质就是在问，**JS代码是按顺序执⾏的吗？**， 也就是说我们需要了解JS的运行，**只有理解了JavaScrip的执⾏上下⽂，你才能更好地理解JS语⾔本⾝**，⽐如变量提升、作⽤域和闭包等。

先看这道题：
```js
saySomeThing()
console.log(thing)
var thing = '阿巴阿巴阿巴阿巴'
function saySomeThing() {
    console.log('函数saySomeThing被执⾏');
}
console.log(other)
//如果上面这题按照顺序运行，会是什么样子？当执⾏到第1⾏的时候，
//由于函数saySomeThing还没有定义，所以执⾏应该会报错；
//同样执⾏第2⾏的时候，由于变量thing函数也未定义，所以同样也会报错。
//other 没有定义那就是报错


// 答案如下
// 函数saySomeThing被执⾏
// undefine
// other is not define （报错）
```
看了正确答案你会发现：

1. 在执⾏过程中，若使⽤了未声明的变量，那么JS执⾏会报错。
2. 在⼀个变量定义之前使⽤它，不会出错，但是该变量的值会为undefined，⽽不是定义时的值。
3. 在⼀个函数定义之前使⽤它，不会出错，且函数能正确执⾏。  

第⼀个结论很好理解，因为变量没有定义，这样在执⾏JS代码时，就找不到该变量，所以JS会抛出错误。

但是对于第⼆个和第三个结论，就挺让⼈费解的：

+ 变量和函数为什么能在其定义之前使⽤？这似乎表明 JS 代码并不是⼀⾏⼀⾏执⾏的。
+ 同样的⽅式，变量和函数的处理结果为什么不⼀样？⽐如上⾯的执⾏结果，提前使⽤的 saySomeThing 函数能打印出来完整结果，但是提前使⽤的thing 变量值却是 undefined，⽽不是定义时使⽤的“阿巴阿巴”这个值。


### 变量提升（Hoisting）

在介绍变量提升之前，我们先通过下⾯这段代码，来看看什么 JS 中的声明和赋值。

```js
var name = '阿巴阿巴'
// 本质是将其分成了两部分
// 1. var name （声明了一个变量）
// 2. name = ‘阿巴阿巴’ （对变量进行赋值操作）

```
那么函数呢？

```js
test1()
test2()
function test1(){
    console.log('test1')
}
var test2 = function(){
    console.log('test2')
}
// 运行一下看看就知道了
// test1
// Uncaught TypeError: test2 is not a function

//********整体代码可以解析如下运行********
function test1(){
    console.log('test1')
}
var test2
test1()
test2()
test2 = function(){
    console.log('test2')
}

```
其实看到这里，你应该明白了，函数声明（test1）是可以变量提升的，而函数表达式（test2），本质还是只是申明了一个test2，但是调用前没有赋值，所以报错了。

上面两个例子，函数和变量在执⾏之前都提升到了代码开头。

**所谓的变量提升，是指在 JS 代码执⾏过程中，JS 引擎把变量的声明部分和函数的声明部分提升到代码开头的“⾏为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。**


### JS代码的执⾏流程

从概念的字⾯意义上来看，“变量提升”意味着变量和函数的声明会在物理层⾯移动到代码的最前⾯，正如我们所模拟的那样。但，这并不准确。**实际上变量和函数声明在代码⾥的位置是不会改变的，⽽且是在编译阶段被 JS 引擎放⼊内存中**。也就是说，⼀段JS代码在执⾏之前需要被JS引擎编译，编译完成之后，才会进⼊执⾏阶段。⼤致流程参考下图：

<img :src="$withBase('/image/JS的执行流程.png')" alt="JS的执行流程"  height='100'/>

#### 1. 编译阶段

结合上面例子，看图：

<img :src="$withBase('/image/JS执行流程细化图.png')" alt="JS执行流程细化图"  height='400'/>

从上图可以看出，输⼊⼀段代码，经过编译后，会⽣成两部分内容：**执⾏上下⽂（Execution context）和可执⾏代码。**

**执⾏上下⽂是JS执⾏⼀段代码时的运⾏环境**，⽐如调⽤⼀个函数，就会进⼊这个函数的执⾏上下⽂，确定该函数在执⾏期间⽤到的诸如this、变量、对象以及函数等。

```js
saySomeThing()
console.log(thing)
var thing = '阿巴阿巴阿巴阿巴'
function saySomeThing() {
    console.log('函数saySomeThing被执⾏');
}
```

还是来分析这个例子

+ 第1⾏和第2⾏，由于这两⾏代码不是声明操作，所以 JS 引擎不会做任何处理；
+ 第3⾏，由于这⾏是经过var声明的，因此 JS 引擎将在环境对象中创建⼀个名为 thing 的属性，
并使⽤undefined对其初始化；
+ 第4⾏，JS 引擎发现了⼀个通过 function 定义的函数，所以它将函数定义存储到堆(HEAP）中，并在环境对象中创建⼀个saySomeThing的属性，然后将该属性值指向堆中函数的位置。  


#### 2. 执⾏阶段

JS引擎开始执⾏“可执⾏代码”，按照顺序⼀⾏⼀⾏地执⾏。下⾯我们就来⼀⾏⼀⾏分析下这个执⾏过程：

+ 当执⾏到saySomeThing函数时，JS引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引⽤，所以JS引擎便开始执⾏该函数，并输出“函数saySomeThing被执⾏”结果。

+ 接下来打印“thing”信息，JS 引擎继续在变量环境对象中查找该对象，由于变量环境存在 thing 变量，并且其值为 undefined，所以这时候就输出 undefined。

+ 接下来执⾏第3⾏，把“阿巴阿巴阿巴阿巴”赋给 thing 变量，赋值后变量环境中的 thing 属性值改变为“阿巴阿巴阿巴阿巴”。

**需要注意，js内没有重载的概念，所以遇到同名函数，后一个会覆盖前一个函数的**