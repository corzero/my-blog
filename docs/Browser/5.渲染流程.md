---
title: 5.渲染流程
date: 2021-03-04 21:43
---

## 前言 

HTML渲染问题是一个面试基本上都会提及的问题，可有些人只能回答零星半点（说的就是真正看这篇文章的你😁）。这个问题也恰好是浏览器内部流程中一个非常重要的知识点，不讲不行，那么上篇文字讲到提交文档后，就要准备渲染了，那浏览器如何渲染呢？

## 三把斧🪓

作为前端工程狮，你不得不学会这三把斧：

+ **HTML**：超文本标记语言，是一种标记语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。  

通俗：你的身体结构。

+ **CSS**：层叠样式表是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。  

通俗：你身上穿的衣服。

+ **JS**：是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。  

通俗：你的行为动作。 

<br />

你看，多么简洁的概念啊，可这三个像形成结界一样困扰了绝大部分程序猿（媛），当然包括我🐶，不过这三个概念我相信你们已经理解，且会用（永远不要说精通，那都是骗人的）。

## 机制

渲染机制复杂难懂，所以渲染模块在执⾏过程中通常会有多个阶段，每个阶段处理的内容是不一样的，得按顺序依次进行，最后输出像素。如下图所示：

<img :src="$withBase('/image/渲染队列.png')" alt="渲染队列"/>


别被这么多阶段吓到了，其实仔细观察就会发现，这么多内容归纳在一起就是三部：**输入->处理->输出**

## 过程

###  1. **DOM树的构建**   

  <img :src="$withBase('/image/DOM树.png')" alt="DOM树"/>   

其实浏览器是无法直接使用HTML的，他需要被浏览器的**HTML解析器**转化为AST语法树🌲，这棵树，我们叫**DOM树**，有兴趣可以看看这篇文章👉[从Chrome源码看浏览器如何构建DOM树](https://zhuanlan.zhihu.com/p/24911872)

<br/>

###  2. **样式计算**   

<img :src="$withBase('/image/CSSOM.png')" alt="CSSOM" height="400"/>   

我们在HTML引入的外部样式CSS文件，或者在HTML中写的内部样式Style代码块，还有标签上的行内样式。同HTML一样，也有个专门的CSS解析器负责解析成为**styleSheets**。

+ 渲染引擎会把获取到的CSS⽂本全部转换为**styleSheets**结构，该结构有查询和修改css的功能。

+ 在解析的过程中会进行值转化。值转化就是将css某些单位（em，rem，vh等）转化为px。如下：

```css
body{
    font-size:2em; // => font-size:32px
    color:red, // => color:rgb(255,0,0) 
}
```   
+ 计算DOM上每个点具体样式，在这个阶段会进行样式继承，就是子样式的某些属性会继承父样式，最常见的属性是**font-xxx**，而计算样式则涉及到CSS的继承规则和层叠规则了。
  ⾸先是CSS继承。CSS继承就是每个DOM节点都包含有⽗节点的样式。这么说可能有点抽象，看下⾯这样⼀张样式表是如何应⽤到DOM节点上的。

  <img :src="$withBase('/image/样式继承计算.png')" alt="样式继承计算" height="400"/> 

  图中所有⼦节点都继承了⽗节点样式。⽐如body节点的font-size属性是20，那body节点下⾯的所有节点的font-size都等于20。另外如果无法很直观看出这些内容的话，也可以参考 F12-> Element -> 选择某个节点 -> Style 查看继承关系。

  <img :src="$withBase('/image/浏览器样式继承.png')" alt="浏览器样式继承" height="300"/> 

<br/>

### 3. **布局阶段**   

  虽然有DOM树和DOM树中元素的样式，但这还是无法显⽰完整⻚⾯，因为此时还不知道DOM元素在浏览器上的位置信息。所以需要计算出DOM树中元素的位置，而这个过程叫做布局。目前在Chrome中在布局中会进行两个阶段：   

  + **创建布局树**   

  先看图：  

  <img :src="$withBase('/image/创建布局树.png')" alt="创建布局树" height="300"/>   

  需要注意，在 HTML 中 并不是所有的标签都是需要展示的，比如`<script>`、`<head>`, `<style>`或者设置了`display:none`的CSS，因此在显⽰之前，还要额外地构建⼀棵只包含可⻅元素布局树。

  在这个过程中主要：**遍历DOM树中的所有可⻅节点，并把这些节点加到布局中**  

<br/>

### 4. **分层**   

  有了⼀棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。但因为⻚⾯中有很多复杂的效果，如3D变换、⻚⾯滚动，z-index的转化等，为了实现这些效果，**渲染引擎还需要为特定的DOM节点⽣成专⽤的图层，并为其对应⽣成⼀棵图层树（LayerTree）**。

  F12 -> More(右侧三个点) -> Layers ，内容查看如下：

  <img :src="$withBase('/image/渲染图层分布.png')" alt="渲染图层分布" height="300"/>   

  渲染引擎给⻚⾯分了很多图层，这些图层按照⼀定顺序叠加在⼀起，就形成了最终的图层分布，而图层分布与布局树和图层树的关系如下：   

  <img :src="$withBase('/image/布局树和图层树关系.png')" alt="布局树和图层树关系" height="300"/>   

  需要注意的是，**并不是布局树🌲上的所有节点都会创建一个图层，那样太复杂，对渲染进程来讲很费时费力，如果一个节点没有对应的图层，那么该节点隶属于父节点的图层。**   

  会有人问，怎么判断节点是否创建一个属于自己的图层？ 在CSS条件中只要满足其中一个条件，就生层自有图层。

  + **拥有层叠上下⽂属性的元素会被提升为单独的⼀层**  

  层叠上下⽂属性: `z-index`,`position`,`opacity`,`filter`等，戳👉[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)

  怎么理解这个？首先要明白，页面是个二维平面，但是层叠上下⽂属性能够让元素具有三维的概念，按照自身属性对比当前层叠上下⽂生成优先级，然后按顺序垂直排序在HTML的Z轴上，如下图：  

  <img :src="$withBase('/image/层叠上下文.png')" alt="层叠上下文" height="400"/>    

  + **溢出内容会创建单独图层**  

  如何理解这句话？描述一下这个场景，在一个定宽的 div 中，内容超过了当前宽高，那么此时 div 内容默认是不显示溢出内容的，内容被裁剪掉了，渲染时会为当前div内容创建一个单独图层，如果出现滚动条，那么滚动条也会创建一个图层。如下图所示：

  <img :src="$withBase('/image/内容溢出图层.png')" alt="内容溢出图层" height="400"/>   

<br />


### 5. **图层绘制（Layer drawing）**  

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进⾏绘制。绘制是一个很复杂的过程，浏览器的渲染引擎在绘制图层时会把每个图层才分成多个绘制指令，然后将每个指令按照顺序组合成一个绘制列表，Chrome中 F12 -> Layers -> document 查看，示意图如下：

 <img :src="$withBase('/image/浏览器绘制列表.png')" alt="浏览器绘制列表" height="400"/>  

<br />

###  6. **栅格化操作（Rasterization operation）**  

绘制列表只是⽤来记录绘制顺序和绘制指令的列表，⽽实际上绘制操作是由渲染引擎中的合成线程来完成的。结合下图来看下渲染主线程和合成线程之间的关系：

<img :src="$withBase('/image/浏览器绘制列表.png')" alt="浏览器绘制列表" height="400"/>   


如上图所⽰，当图层的绘制列表准备好之后，主线程会把该绘制列表**提交**（commit）给合成线程，谈到合成线程，我们需要回答一个问题：**什么是视窗**（viewport）？    

<img :src="$withBase('/image/浏览器视窗.png')" alt="浏览器视窗" height="400"/>   

看完这个图，再结合我们之前浏览过的一些大型网站，其实你会发现，某些网站的内容特别多，需要滚动很长时间才能到底。我们真正看到的内容只有视窗大小，如果渲染引擎真的要把整个网页全部进行栅格化操作，会产生巨大开销，这么没必要。  

为此，合成线程在此处的左右就是 **将图层划分为图块** ，将内容划分为256**256或者512**512大小的图块。

<img :src="$withBase('/image/浏览器图块.png')" alt="浏览器图块" height="400"/>  


合成线程会按照视窗附近的图块来优先⽣成位图，实际⽣成位图的操作是由栅格化来执⾏的。而栅格化，是指将图块转换为位图，图块是栅格化执⾏的最⼩单位。渲染进程维护了⼀个栅格化的线程池，所有的图块栅格化都是在线程池内执⾏的，运⾏⽅式如下图所⽰： 

<img :src="$withBase('/image/浏览器图块栅格化.png')" alt="浏览器图块栅格化" height="400"/>  

在栅格化过程，因为都是单一的重复性工作，所以都会使⽤GPU来加速⽣成（GPU的计算单元相比CPU更多，详情戳👉[GPU和CPU区别](https://www.zhihu.com/question/19903344)），而使⽤GPU⽣成位图的过程叫快速栅格化，或者GPU栅格化，⽣成的位图被保存在GPU内存中，这里需要注意的是，这个过程中调用了GPU，属于**跨进程操作**：

<img :src="$withBase('/image/浏览器渲染和GPU通信.png')" alt="浏览器渲染和GPU通信" height="500"/>  


### 6. 合成和显⽰  

⼀旦所有图块都被光栅化，合成线程就会⽣成⼀个绘制图块的命令⸺“DrawQuad”，然后将该命令提交给浏览器进程。   

浏览器进程⾥⾯有⼀个叫viz的组件，⽤来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其⻚⾯内容绘制到内存中，最后再将内存显⽰在屏幕上。  

到这⾥，经过这⼀系列的阶段，编写好的HTML、CSS、JS等⽂件，经过浏览器就会显⽰出漂亮的⻚⾯了。



### 其他： 重排 && 重绘 && 合成阶段

  + **重排**：更新了元素的⼏何属性。    

    <img :src="$withBase('/image/重排.png')" alt="重排" />  

    什么是几何属性？`height`、`width`、`position`、`top`、`left`等这些属性，通过JS或者Css修改后，会触发重新解析、布局的过程叫**重排**，注意的是**重排需要更新完整的渲染流⽔线，它的开销也是最⼤的**，这也是前端优化常用手法之一。

  <br /> 


  + **重绘**：更新元素的绘制属性。  

    <img :src="$withBase('/image/重绘.png')" alt="重绘" />  

    什么是绘制属性？ `color`、`background`、`opacity`等这些属性，如通过JS更改某些元素的绘制属性，不会影响布局，就直接进⼊了绘制阶段这个过程叫**重绘**，注意的是**重绘省去了布局和分层阶段，所以执⾏效率会⽐重排操作要高**。




# 总结   

这个Part的内容有点繁杂，会很枯燥，但还是需要理解看一下。这篇文章主要还是说明了整个渲染的流程，包括 HTML -> DOM、 样式计算、布局、图层、绘制、光栅化、合成、显示。

<img :src="$withBase('/image/浏览器渲染完整流程.png')" alt="浏览器渲染完整流程" height="500"/>    

如图，整体流程简单概括以下几点：   

1. 渲染进程将HTML内容转换为能够读懂的**DOM树结构**。

2. 渲染引擎将CSS样式表转化为浏览器可以理解的**StyleSheets**，计算出DOM节点的样式。

3. 创建**布局树**，并计算元素的布局信息。

4. 对布局树进⾏**分层**，并⽣成**分层树**。

5. 为每个图层⽣成**绘制列表**，并将其提交到合成线程。

6. 合成线程将图层分成**图块**，并在光栅化线程池中将图块转换成位图。

7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。

8. 浏览器进程根据DrawQuad消息**⽣成⻚⾯**，并显⽰到显⽰器上。










