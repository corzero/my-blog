---
title: 21.分层和合成机制
date: 2021-06-09 23:03
---

## 前言
我们介绍过DOM树⽣成之后，还要经历布局、分层、绘制、合成、显⽰等阶段后才能显⽰出漂亮的⻚⾯。而与h5处理的同时css3也跟着一起处理，其中最大的一个特性就是动画。有人会质疑，明明js可以实现各种各样的动画为啥css3还要新增动画呢？这篇文章大概可以解决这个问题，讲解渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术，Chrome团队为了做到这⼀点，做了⼤量的优化⼯作。了解其⼯作原理，有助于拓宽你的视野，⽽且也有助于你更加深刻地理解CSS动画和JS底层⼯作机制。

## 显⽰器是怎么显⽰图像的

每个显⽰器都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图⽚，更新的图⽚都来⾃于显卡中⼀个叫**前缓冲区**的地⽅，显⽰器所做的任务很简单，就是每秒固定读取60次前缓冲区中的图像，并将读取的图像显⽰到显⽰器上。

**显卡的作用呢？**

显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，⼀旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显⽰器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显⽰器的刷新频率是⼀致的。但有时候，在⼀些复杂的场景中，显卡处理⼀张图⽚的速度会变慢，这样就会造成视觉上的卡顿。

## 帧 VS 帧率
了解了显⽰器是怎么显⽰图像的之后，下⾯我们再来明确下帧和帧率的概念，因为这是后续⼀切分析的基础。

当你通过滚动条滚动⻚⾯，或者通过⼿势缩放⻚⾯时，屏幕上就会产⽣动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流⽔线⽣成新的图⽚，并发送到显卡的后缓冲区。

⼤多数设备屏幕的更新频率是60次/秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新60张图⽚到显卡的后缓冲区。

我们把渲染流⽔线⽣成的每⼀副图⽚称为⼀帧，把渲染流⽔线每秒更新了多少帧称为帧率，⽐如滚动过程中1秒更新了60帧，那么帧率就是60Hz（或者60FPS）。

由于⽤户很容易观察到那些丢失的帧，如果在⼀次动画过程中，渲染引擎⽣成某些帧的时间过久，那么⽤户就会感受到卡顿，这会给⽤户造成⾮常不好的印象。

要解决卡顿问题，就要解决每帧⽣成时间过久的问题，为此Chrome对浏览器渲染⽅式做了⼤量的⼯作，其中最卓有成效的策略就是引⼊了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术

## 如何⽣成⼀帧图像

我们先回顾一下渲染引擎是如何⽣成⼀帧图像的。关于其中任意⼀帧的⽣成⽅式，有重排、重绘和合成三种⽅式。

这三种⽅式的渲染路径是不同的，通常渲染路径越⻓，⽣成图像花费的时间就越多。⽐如重排，它需要重新根据CSSOM和DOM来计算布局树，这样⽣成⼀幅图⽚时，会让整个渲染流⽔线的每个阶段都执⾏⼀遍，如果布局复杂的话，就很难保证渲染的效率了。⽽重绘因为没有了重新布局的阶段，操作效率稍微⾼点，但是依然需要重新计算绘制信息，并触发绘制操作之后的⼀系列操作。

相较于重排和重绘，**合成操作**的路径就显得⾮常短了，并不需要触发布局和绘制两个阶段，如果采⽤了GPU，那么合成的效率会⾮常⾼。

所以，关于渲染引擎⽣成⼀帧图像的⼏种⽅式，按照效率我们推荐合成⽅式优先，若实在不能满⾜需求，那么就再退后⼀步使⽤重绘或者重排的⽅式。

本⽂我们的焦点在合成上，所以接下来我们就来深⼊分析下Chrome浏览器是怎么实现合成操作的。Chrome中的合成技术，可以⽤三个词来概括总结：**分层、分块和合成**。

## 分层和合成

通常⻚⾯的组成是⾮常复杂的，有的⻚⾯⾥要实现⼀些复杂的动画效果，⽐如点击菜单时弹出菜单的动画特效，滚动⿏标滚轮时⻚⾯滚动的动画效果，当然还有⼀些炫酷的3D动画特效。如果没有采⽤分层机制，从布局树直接⽣成⽬标图⽚的话，那么每次⻚⾯有很⼩的变化时，都会触发重排或者重绘机制，这种“牵⼀发⽽动全⾝”的绘制策略会严重影响⻚⾯的渲染效率。

为了提升每帧的渲染效率，Chrome引⼊了分层和合成的机制。那该怎么来理解分层和合成机制呢？

你可以把⼀张⽹⻚想象成是由很多个图⽚叠加在⼀起的，每个图⽚就对应⼀个图层，Chrome合成器最终将这些图层合成了⽤于显⽰⻚⾯的图⽚。如果你熟悉PhotoShop的话，就能很好地理解这个过程了，PhotoShop中⼀个项⽬是由很多图层构成的，每个图层都可以是⼀张单独图⽚，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在⼀起后，就能呈现出最终的图⽚了。

在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到⼀起的操作就称为合成。
所以，分层和合成通常是⼀起使⽤的。

考虑到⼀个⻚⾯被划分为两个层，当进⾏到下⼀帧的渲染时，上⾯的⼀帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者Alpha渐变，这时候合成器只需要将两个层进⾏相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间⾮常短。

**理解了为什么要引⼊合成和分层机制，下⾯我们再来看看Chrome是怎么实现分层和合成机制的。**

在Chrome的渲染流⽔线中，**分层体现在⽣成布局树之后**，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流⽔线后续流程的基础结构。

层树中的每个节点都对应着⼀个图层，下⼀步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图⽚，⽽是将绘制指令组合成⼀个列表，⽐如⼀个图层要设置的背景为⿊⾊，并且还要在中间画⼀个圆形，那么绘制过程会⽣成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进⼊光栅化阶段了，光栅化就是按照绘制列表中的指令⽣成图⽚。每⼀个图层都对应⼀张图⽚，合成线程有了这些图⽚之后，会将这些图⽚合成为“⼀张”图⽚，并最终将⽣成的图⽚发送到后缓冲区。这就是⼀个⼤致的分层、合成流程。

**需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执⾏合成操作时，是不会影响到主线程执⾏的。这就是为什么经常主线程卡住了，但是CSS动画依然能执⾏的原因。**


### 分块
如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层⾯提升了渲染效率。

通常情况下，⻚⾯的内容都要⽐屏幕⼤得多，显⽰⼀个⻚⾯时，如果等待所有的图层都⽣成完毕，再进⾏合成的话，会产⽣⼀些不必要的开销，也会让合成图⽚的时间变得更久。

因此，合成线程会将每个图层分割为⼤⼩固定的图块，然后优先绘制靠近视⼝的图块，这样就可以⼤⼤加速⻚⾯的显⽰速度。不过有时候， 即使只绘制那些优先级最⾼的图块，也要耗费不少的时间，因为涉及到⼀
个很关键的因素⸺纹理上传，这是因为从计算机内存上传到GPU内存的操作会⽐较慢。

为了解决这个问题，Chrome⼜采取了⼀个策略：在⾸次合成图块的时候使⽤⼀个低分辨率的图⽚。⽐如可以是正常分辨率的⼀半，分辨率减少⼀半，纹理就减少了四分之三。在⾸次显⽰⻚⾯内容的时候，将这个低分辨率的图⽚显⽰出来，然后合成器继续绘制正常⽐例的⽹⻚内容，当正常⽐例的⽹⻚内容绘制完成后，再替换掉当前显⽰的低分辨率内容。这种⽅式尽管会让⽤户在开始时看到的是低分辨率的内容，但是也⽐⽤户在开始时什么都看不到要好。

## 如何利⽤分层技术优化代码

通过上⾯的介绍，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图⽚的，理解其中原理之后，你就可以利⽤分层和合成技术来优化代码了。

在写Web应⽤的时候，你可能经常需要对某个元素做⼏何形状变换、透明度变换或者⼀些缩放操作，如果使⽤JS来写这些效果，会牵涉到整个渲染流⽔线，所以JS的绘制效率会⾮常低下。

这时你可以使⽤ `will-change`来告诉渲染引擎你会对该元素做⼀些特效变换，CSS代码如下：

```css
.box {
    will-change: transform, opacity;
}
```

> 需要注意的是，在MDN上对`will-change`的描述是一个实验性功能，项目中自行考虑使用哦。

这段代码就是提前告诉渲染引擎box元素将要做⼏何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现⼀帧，等这些变换发⽣时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就⼤⼤提升了渲染的效率。**这也是CSS动画⽐JS动画⾼效的原因**, 除了`will-change`, 很多诸`translate`等属性都会使用GPU加速。

所以，如果涉及到⼀些可以使⽤合成线程来处理CSS特效或者动画的情况，就尽量使⽤`will-change`来提前告诉渲染引擎，让它为该元素准备独⽴的层。但是凡事都有两⾯性，每当渲染引擎为⼀个元素准备⼀个独⽴层的时候，它占⽤的内存也会⼤⼤增加，因为从层树开始，后续每个阶段都会多⼀个层结构，这些都需要额外的内存，所以你需要恰当地使⽤ `will-change`。