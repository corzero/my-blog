---
title: 12.垃圾回收（GC）
date: 2020-05-29
---

# 前言

其实 GC 这个问题，得益于浏览器的 V8 引擎，GC 这方便我们开发者并不是很关心，V8 会自动帮助我们去回收那些没用的内存，但我发现，周围的人还是在背诵古老的那一套回收机制，在前端快速发展的浪潮中，浏览器技术发展也非常快，前端的应用也在逐渐变的庞大，GC的方式其实也在不停进步。所以这个章节，我们了解一下新时代浏览器中V8的回收机制吧。

## 为什么需要 GC ？

在我们前端应用当中会大量的声明、赋值和修改，不过有些数据被使⽤之后，可能就不再需要了，我们把这种数据称为**垃圾数据**。如果这些垃圾数据⼀直保存在内存中，那么内存会越⽤越多，所以我们需要对这些垃圾数据进⾏回收，以释放有限的内存空间。

## 如何 GC ？

需要说明我们在之前说过的是，JS 中的数据存储无非在栈和堆，所以我们主要是通过这两个方面来描述 GC 的基本流程，需要说明，GC本身是一个很复杂的操作，背后的原理我们也只是简单介绍。

### 栈空间的 GC

```js
function foo(){
    var a = 1
    var b = {name:"极客邦"}
    function showName(){
        var c = "极客时间"
        var d = { name:"极客时间" }
    }
    showName()
}

foo()

```
当执⾏到第7⾏代码时，其调⽤栈和堆空间状态图如下所⽰：

<img :src="$withBase('/image/垃圾回收1.png')" alt="垃圾回收1" height="400"/> 

执⾏到showName函数时的内存模型从图中可以看出，原始类型的数据被分配到栈中，引⽤类型的数据会被分配到堆中。

当foo函数执⾏结束之后，foo函数的执⾏上下⽂会从堆中被销毁掉，那么它是怎么被销毁的呢？下⾯我们就来分析⼀下。在上篇⽂章中，我们简单介绍过了，如果执⾏到showName函数时，那么 JS 引擎会创建showName函数的执⾏上下⽂，并将showName函数的执⾏上下⽂压⼊到调⽤栈中，最终执⾏到showName函数时，其调⽤栈就如上图所⽰。与此同时，还有⼀个**记录当前执⾏状态的指针（称为 ESP ）**，指向调⽤栈中showName函数的执⾏上下⽂，表⽰当前正在执⾏showName函数。

接着，当showName函数执⾏完成之后，函数执⾏流程就进⼊了foo函数，那这时就需要销毁showName函数的执⾏上下⽂了。 ESP 这时候就帮上忙了， JS 会将 ESP 下移到foo函数的执⾏上下⽂，**这个下移操作就是销毁showName函数执⾏上下⽂的过程**。

你可能会有点懵， ESP 指针向下移动怎么就能把showName的执⾏上下⽂销毁了呢？具体你可以看下⾯这张移动 ESP 前后的对⽐图：

<img :src="$withBase('/image/垃圾回收2.png')" alt="垃圾回收2" height="400"/> 

从图中可以看出，当showName函数执⾏结束之后，ESP向下移动到foo函数的执⾏上下⽂中，上⾯showName的执⾏上下⽂虽然保存在栈内存中，但是已经是⽆效内存了。⽐如当foo函数再次调⽤另外⼀个函数时，这块内容会被直接覆盖掉，⽤来存放另外⼀个函数的执⾏上下⽂。

所以说，当⼀个函数执⾏结束之后，** JS 引擎会通过向下移动ESP来销毁该函数保存在栈中的执⾏上下⽂**。

### 堆空间的 GC

刚刚我们讲了，foo函数执⾏结束之后，ESP应该是指向全局执⾏上下⽂的，那么showName函数和foo函数的执⾏上下⽂就处于⽆效状态了，但我们声明的两个对象：`b` 和 `d` 还在，堆内存中：

<img :src="$withBase('/image/垃圾回收3.png')" alt="垃圾回收3" height="400"/>

从图中可以看出，1003和1050这两块内存依然被占⽤。要回收堆中的垃圾数据，就需要⽤到 JS 中的**垃圾回收器**。

那么现在，我们来了解一下 Chrome 的 JS 引擎V8来分析下堆中的垃圾数据是如何回收的。[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)

## 代际假说和分代收集

不过在正式介绍V8是如何实现回收之前，**代际假说**（The Generational Hypothesis）这个概念很多人没听过（可以查看朴灵的《深入浅出Node.js》），这是垃圾回收领域中⼀个重要的术语，后续垃圾回收的策略都是建⽴在该假说的基础之上的，所以很是重要。

代际假说有以下两个特点：

+ 第⼀个是⼤部分对象在内存中存在的时间很短，简单来说，就是很多对象⼀经分配内存，很快就变得不可访问

+ 第⼆个是不死的对象，会活得更久

通常，垃圾回收算法有很多种，但是并没有哪⼀种能胜任所有的场景，你需要权衡各种场景，根据对象的⽣存周期的不同⽽使⽤不同的算法，以便达到最好的效果。

所以，在V8中会把堆分为**新⽣代和⽼⽣代**两个区域，**新⽣代中存放的是⽣存时间短的对象，⽼⽣代中存放的⽣存时间久的对象**。

新⽣区通常只⽀持1〜8M的容量，⽽⽼⽣区⽀持的容量就⼤很多了。对于这两块区域，V8分别使⽤两个不同的垃圾回收器，以便更⾼效地实施垃圾回收。

+ **副垃圾回收器，主要负责新⽣代的垃圾回收。**

+ **主垃圾回收器，主要负责⽼⽣代的垃圾回收。**

## 垃圾回收器的⼯作流程

其实不论什么语言类型的垃圾回收器，它们都有⼀套极其相似的执⾏流程。

1. 标记空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏垃圾回收的对象。

2. 回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可回收的对象。

3. 内存整理

需要注意的是，第三步是可选择的，不同的浏览器厂商会有一些差异，⼀般来说，频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的
内存空间称为**内存碎⽚**。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可能出现内存不⾜的情况，需要整理这些内存碎⽚。但是有些垃圾回收器是不会产生碎片的，例如**副垃圾回收器**

### 副垃圾回收器

副垃圾回收器主要负责新⽣区的垃圾回收。⽽通常情况下，⼤多数⼩的对象都会被分配到新⽣区，所以说这个区域虽然不⼤，但是垃圾回收还是⽐较频繁的。

新⽣代中⽤**Scavenge**算法来处理。所谓Scavenge算法，是**把新⽣代空间对半划分为两个区域，⼀半是对象区域，⼀半是空闲区域**，如下图所⽰：

<img :src="$withBase('/image/垃圾回收4.png')" alt="垃圾回收4" height="400"/>

新加⼊的对象都会存放到对象区域，当对象区域快被写满时，就需要执⾏⼀次垃圾清理操作。

在垃圾回收过程中，⾸先要对对象区域中的垃圾做标记；标记完成之后，就进⼊垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎⽚了。

完成复制后，对象区域与空闲区域进⾏⻆⾊翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**⻆⾊翻转的操作还能让新⽣代中的这两块区域⽆限重复使⽤下去**。