---
title: 12.垃圾回收（GC）
date: 2021-05-02 04:43
---

# 前言

其实 GC 这个问题，得益于浏览器的 V8 引擎，GC 这方便我们开发者并不是很关心，V8 会自动帮助我们去回收那些没用的内存，但我发现，周围的人还是在背诵古老的那一套回收机制，在前端快速发展的浪潮中，浏览器技术发展也非常快，前端的应用也在逐渐变的庞大，GC的方式其实也在不停进步。所以这个章节，我们了解一下新时代浏览器中V8的回收机制吧。

## 为什么需要 GC ？

在我们前端应用当中会大量的声明、赋值和修改，不过有些数据被使⽤之后，可能就不再需要了，我们把这种数据称为**垃圾数据**。如果这些垃圾数据⼀直保存在内存中，那么内存会越⽤越多，所以我们需要对这些垃圾数据进⾏回收，以释放有限的内存空间。

## 如何 GC ？

需要说明我们在之前说过的是，JS 中的数据存储无非在栈和堆，所以我们主要是通过这两个方面来描述 GC 的基本流程，需要说明，GC本身是一个很复杂的操作，背后的原理我们也只是简单介绍。

### 栈空间的 GC

```js
function foo(){
    var a = 1
    var b = { name:"阿木" }
    function showName(){
        var c = "拓海"
        var d = { name:"拓海" }
    }
    showName()
}

foo()

```
当执⾏到第8⾏代码时，其调⽤栈和堆空间状态图如下所⽰：

<img :src="$withBase('/image/垃圾回收1.png')" alt="垃圾回收1" height="400"/> 

执⾏到showName函数时的内存模型从图中可以看出，原始类型的数据被分配到栈中，引⽤类型的数据会被分配到堆中。

当foo函数执⾏结束之后，foo函数的执⾏上下⽂会从堆中被销毁掉，那么它是怎么被销毁的呢？下⾯我们就来分析⼀下。在上篇⽂章中，我们简单介绍过了，如果执⾏到showName函数时，那么 JS 引擎会创建showName函数的执⾏上下⽂，并将showName函数的执⾏上下⽂压⼊到调⽤栈中，最终执⾏到showName函数时，其调⽤栈就如上图所⽰。与此同时，还有⼀个**记录当前执⾏状态的指针（称为 ESP ）**，指向调⽤栈中showName函数的执⾏上下⽂，表⽰当前正在执⾏showName函数。

接着，当showName函数执⾏完成之后，函数执⾏流程就进⼊了foo函数，那这时就需要销毁showName函数的执⾏上下⽂了。 ESP 这时候就帮上忙了， JS 会将 ESP 下移到foo函数的执⾏上下⽂，**这个下移操作就是销毁showName函数执⾏上下⽂的过程**。

你可能会有点懵， ESP 指针向下移动怎么就能把showName的执⾏上下⽂销毁了呢？具体你可以看下⾯这张移动 ESP 前后的对⽐图：

<img :src="$withBase('/image/垃圾回收2.png')" alt="垃圾回收2" height="400"/> 

从图中可以看出，当showName函数执⾏结束之后，ESP向下移动到foo函数的执⾏上下⽂中，上⾯showName的执⾏上下⽂虽然保存在栈内存中，但是已经是⽆效内存了。⽐如当foo函数再次调⽤另外⼀个函数时，这块内容会被直接覆盖掉，⽤来存放另外⼀个函数的执⾏上下⽂。

所以说，当⼀个函数执⾏结束之后，**JS 引擎会通过向下移动ESP来销毁该函数保存在栈中的执⾏上下⽂**。

### 堆空间的 GC

刚刚我们讲了，foo函数执⾏结束之后，ESP应该是指向全局执⾏上下⽂的，那么showName函数和foo函数的执⾏上下⽂就处于⽆效状态了，但我们声明的两个对象：`b` 和 `d` 还在，堆内存中：

<img :src="$withBase('/image/垃圾回收3.png')" alt="垃圾回收3" height="400"/>

从图中可以看出，0001和0002这两块内存依然被占⽤。要回收堆中的垃圾数据，就需要⽤到 JS 中的**垃圾回收器**。

那么现在，我们来了解一下 Chrome 的 JS 引擎V8来分析下堆中的垃圾数据是如何回收的。[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)

## 代际假说和分代收集

不过在正式介绍V8是如何实现回收之前，**代际假说**（The Generational Hypothesis）这个概念很多人没听过（可以查看朴灵的《深入浅出Node.js》），这是垃圾回收领域中⼀个重要的术语，后续垃圾回收的策略都是建⽴在该假说的基础之上的，所以很是重要。

代际假说有以下两个特点：

+ 第⼀个是⼤部分对象在内存中存在的时间很短，简单来说，就是很多对象⼀经分配内存，很快就变得不可访问

+ 第⼆个是不死的对象，会活得更久

通常，垃圾回收算法有很多种，但是并没有哪⼀种能胜任所有的场景，你需要权衡各种场景，根据对象的⽣存周期的不同⽽使⽤不同的算法，以便达到最好的效果。

所以，在V8中会把堆分为**新⽣代和⽼⽣代**两个区域，**新⽣代中存放的是⽣存时间短的对象，⽼⽣代中存放的⽣存时间久的对象**。

新⽣区通常只⽀持1〜8M的容量，⽽⽼⽣区⽀持的容量就⼤很多了。对于这两块区域，V8分别使⽤两个不同的垃圾回收器，以便更⾼效地实施垃圾回收。

+ **副垃圾回收器，主要负责新⽣代的垃圾回收。**

+ **主垃圾回收器，主要负责⽼⽣代的垃圾回收。**

## 垃圾回收器的⼯作流程

其实不论什么语言类型的垃圾回收器，它们都有⼀套极其相似的执⾏流程。

1. 标记空间中活动对象和⾮活动对象。所谓活动对象就是还在使⽤的对象，⾮活动对象就是可以进⾏垃圾回收的对象。

2. 回收⾮活动对象所占据的内存。其实就是在所有的标记完成之后，统⼀清理内存中所有被标记为可回收的对象。

3. 内存整理

需要注意的是，第三步是可选择的，不同的浏览器厂商会有一些差异，⼀般来说，频繁回收对象后，内存中就会存在⼤量不连续空间，我们把这些不连续的
内存空间称为**内存碎⽚**。当内存中出现了⼤量的内存碎⽚之后，如果需要分配较⼤连续内存的时候，就有可能出现内存不⾜的情况，需要整理这些内存碎⽚。但是有些垃圾回收器是不会产生碎片的，例如**副垃圾回收器**

### 副垃圾回收器

副垃圾回收器主要负责新⽣区的垃圾回收。⽽通常情况下，⼤多数⼩的对象都会被分配到新⽣区，所以说这个区域虽然不⼤，但是垃圾回收还是⽐较频繁的。

新⽣代中⽤**Scavenge**算法来处理。所谓Scavenge算法，是**把新⽣代空间对半划分为两个区域，⼀半是对象区域，⼀半是空闲区域**，如下图所⽰：

<img :src="$withBase('/image/垃圾回收4.png')" alt="垃圾回收4" height="400"/>

新加⼊的对象都会存放到对象区域，当对象区域快被写满时，就需要执⾏⼀次垃圾清理操作。

在垃圾回收过程中，⾸先要对对象区域中的垃圾做标记；标记完成之后，就进⼊垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎⽚了。

完成复制后，对象区域与空闲区域进⾏⻆⾊翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**⻆⾊翻转的操作还能让新⽣代中的这两块区域⽆限重复使⽤下去**。

由于新⽣代中采⽤的Scavenge算法，所以每次执⾏清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新⽣区空间设置得太⼤了，那么每次清理的时间就会过久，所以为了执⾏效率，**⼀般新⽣区的空间会被设置得⽐较⼩**。

也正是因为新⽣区的空间不⼤，所以很容易被存活的对象装满整个区域。为了解决这个问题，JS引擎采⽤了对象晋升策略，也就是**经过两次垃圾回收依然还存活的对象，会被移动到⽼⽣区中**。

### 主垃圾回收器

主垃圾回收器主要负责⽼⽣区中的垃圾回收。除了新⽣区中晋升的对象，⼀些⼤的对象会直接被分配到⽼⽣区。因此⽼⽣区中的对象有两个特点，⼀个是对象占⽤空间⼤，另⼀个是对象存活时间⻓。

由于⽼⽣区的对象⽐较⼤，若要在⽼⽣区中使⽤Scavenge算法进⾏垃圾回收，复制这些⼤的对象将会花费⽐较多的时间，从⽽导致回收执⾏效率不⾼，同时还会浪费⼀半的空间。因⽽，主垃圾回收器是采⽤**标记清除（Mark-Sweep）**的算法进⾏垃圾回收的。下⾯我们来看看该算法是如何⼯作的。

⾸先是标记过程阶段。标记阶段就是从⼀组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

<img :src="$withBase('/image/垃圾回收的标记清除.png')" alt="垃圾回收的标记清除" height="300"/>

当`showName`函数执⾏结束之后，ESP向下移动，指向了`foo`函数的执⾏上下⽂，这时候如果遍历调⽤栈，是不会找到引⽤0001地址的变量，也就意味着0001这块数据
为垃圾数据，被标记为红⾊。由于0002这块数据被变量b引⽤了，所以这块数据会被标记为活动对象。这就是⼤致的标记过程。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红⾊标记数据的过程，可参考下图⼤致理解下其清除过程：

<img :src="$withBase('/image/标记清除的过程.png')" alt="标记清除的过程" height="400"/>

上⾯的标记过程和清除过程就是标记-清除算法，不过对⼀块内存多次执⾏标记-清除算法后，会产⽣⼤量不连续的内存碎⽚。⽽碎⽚过多会导致⼤对象⽆法分配到⾜够的连续内存，于是⼜产⽣了另外⼀种算法⸺标记-整理（Mark-Compact），这个标记过程仍然与标记-清除算法⾥的是⼀样的，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有存活的对象都向⼀端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

<img :src="$withBase('/image/标记清除的过程2.png')" alt="标记清除的过程2" height="400"/>

### 全停顿

V8是使⽤副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JS是运⾏在主线程之上的，⼀旦执⾏垃圾回收算法，都需要将正在执⾏的JS脚本暂停下来，待垃圾回收完毕后再恢复脚本执⾏。我们把这种⾏为叫做**全停顿（Stop-The-World）**。

⽐如堆中的数据有1.5GB，V8实现⼀次完整的垃圾回收需要1秒以上的时间，这也是由于垃圾回收⽽引起JS线程暂停执⾏的时间，若是这样的时间花销，那么应⽤的性能和响应能⼒都会直线下降。主垃圾回收器执⾏⼀次完整的垃圾回收流程如下图所⽰：

<img :src="$withBase('/image/全停顿.png')" alt="全停顿" height="200"/>


在V8新⽣代的垃圾回收中，因其空间较⼩，且存活对象较少，所以全停顿的影响不⼤，但⽼⽣代就不⼀样了。如果在执⾏垃圾回收的过程中，占⽤主线程时间过久，就像上⾯图⽚展⽰的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的。⽐如⻚⾯正在执⾏⼀个JS动画，因为垃圾回收器在⼯作，就会导致这个动画在这200毫秒内⽆法执⾏的，这将会造成⻚⾯的卡顿现象。

为了降低⽼⽣代的垃圾回收⽽造成的卡顿，V8将标记过程分为⼀个个的⼦标记过程，同时让垃圾回收标记和JS应⽤逻辑交替进⾏，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所⽰：

<img :src="$withBase('/image/全停顿分步执行.png')" alt="全停顿分步执行" height="200"/>

使⽤增量标记算法，可以把⼀个完整的垃圾回收任务拆分为很多⼩的任务，这些⼩的任务执⾏时间⽐较短，可以穿插在其他的JS任务中间执⾏，这样当执⾏上述动画效果时，就不会让⽤户因为垃圾回收任务⽽感受到⻚⾯的卡顿了。
