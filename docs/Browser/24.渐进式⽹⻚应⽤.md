---
title: 24.渐进式⽹⻚应⽤
date: 2021-06-13 22:01
---

## 前言

在之前的篇幅中，其实了解到现在很多大厂都在将他们的应用web化，希望做到即使不下载应用，只是单纯的使用web就能体验到和app一样的功能，这其中Google是推行这种方式的主导者，而这样的应用我们其实称之为PWA应用（渐进式⽹⻚应⽤）。

## 进化路线

浏览器的三⼤进化路线：
+ 应⽤程序Web化
+ Web应⽤移动化
+ Web操作系统化

其中，第⼆个Web应⽤移动化是Google梦寐以求⽽⼜⼀直在发⼒的⼀件事，不过对于移动设备来说，前有本地App，后有移动⼩程序，想要浏览器切⼊到移动端是相当困难的⼀件事，因为浏览器的运⾏性能是低于本地App的，并且Google也没有类似微信或者Facebook这种体量的⽤⼾群体。

但是要让浏览器切⼊到移动端，让其取得和原⽣应⽤同等待遇可是Google的梦想，那该怎么做呢？

PWA则是最佳解决方案，PWA全称是Progressive Web App，翻译过来就是渐进式⽹⻚应⽤。根据字⾯意思，它就是“渐进式+Web应⽤”。对于Web应⽤很好理解了，就是⽬前我们普通的Web⻚⾯，所以PWA所⽀持的⾸先是⼀个Web⻚⾯。⾄于“渐进式”，就需要从下⾯两个⽅⾯来理解。

+ 站在Web应⽤开发者来说，PWA提供了⼀个渐进式的过渡⽅案，让普通站点逐步过渡到Web应⽤。采取渐进式可以降低站点改造的代价，使得站点逐步⽀持各项新技术，⽽不是⼀步到位。

+ 站在技术⻆度来说，PWA技术也是⼀个渐进式的演化过程，在技术层⾯会⼀点点演进，⽐如逐渐提供更好的设备特性⽀持，不断优化更加流畅的动画效果，不断让⻚⾯的加载速度变得更快，不断实现本地应⽤的特性。

从这两点可以看出来，PWA采取的是⾮常⼀个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地App、取代⼩程序。与之相反，⽽是要充分发挥Web的优势，渐进式地缩短和本地应⽤或者⼩程序的距离。

那么Web最⼤的优势是什么呢？我认为是⾃由开放，也正是因为⾃由和开放，所以⼤家就很容易对同⼀件事情达成共识，达成共识之后，⼀套代码就可以运⾏在各种设备之上了，这就是跨平台，这也恰恰是本地应⽤所不具备的。⽽对于⼩程序，倒是可以实现跨平台，但要让各家达成共识，⽬前来看，似乎还是⾮常不切实际的。

所以，PWA的定义就是：它是⼀套理念，渐进式增强Web的优势，并通过技术⼿段渐进式缩短和本地应⽤或者⼩程序的距离。基于这套理念之下的技术都可以归类到PWA。

## Web应⽤ VS 本地应⽤

相对于本地应⽤，Web⻚⾯到底缺少了什么？

+ Web应⽤缺少离线使⽤能⼒，在离线或者在弱⽹环境下基本上是⽆法使⽤的。⽽⽤⼾需要的是沉浸式的体验，在离线或者弱⽹环境下能够流畅地使⽤是⽤⼾对⼀个应⽤的基本要求。

+ Web应⽤还缺少了消息推送的能⼒，因为作为⼀个App⼚商，需要有将消息送达到应⽤的能⼒。

+ Web应⽤缺少⼀级⼊⼝，也就是将Web应⽤安装到桌⾯，在需要的时候直接从桌⾯打开Web应⽤，⽽不是每次都需要通过浏览器来打开。

**针对以上Web缺陷，PWA提出了两种解决⽅案：通过引⼊Service Worker来试着解决离线存储和消息推送的问题，通过引⼊manifest.json来解决⼀级⼊⼝的问题。**下⾯我们就来详细分析下Service Worker是如何⼯作的。


## 什么是Service Worker

>>> Service workers 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。

### 怎么解决离线存储和消息推送问题？

其实在Service Worker之前，WHATWG⼩组就推出过⽤App Cache标准来缓存⻚⾯，不过在使⽤过程中AppCache所暴露的问题⽐较多，遭到多⽅吐槽，所以这个标准最终也只能被废弃了，可⻅⼀个成功的标准是需要经历实践考量的。

所以在2014年的时候，标准委员会就提出了Service Worker的概念，它的主要思想是**在⻚⾯和⽹络之间增加⼀个拦截器，⽤来缓存和拦截请求**。整体结构如下图所⽰：

<img :src="$withBase('/image/ServiceWorker.png')" alt="ServiceWorker"/>

在没有安装Service Worker之前，WebApp都是直接通过⽹络模块来请求资源的。安装了Service Worker模 块之后，WebApp请求资源时，会先通过Service Worker，让它判断是返回Service Worker 缓存的资源还是 重新去⽹络请求资源。⼀切的控制权都交由Service Worker来处理。

### 设计思路？

现在大概了解Service Worker的主要功能就是拦截请求和缓存资源，接下来我们就从Web应⽤的需求⻆度来看看Service Worker的设计思路。

1. 架构

通过前⾯⻚⾯循环系统的分析，我们已经知道了JavaScript和⻚⾯渲染流⽔线的任务都是在⻚⾯主线程上执 ⾏的，如果⼀段JavaScript执⾏时间过久，那么就会阻塞主线程，使得渲染⼀帧的时间变⻓，从⽽让⽤⼾产 ⽣卡顿的感觉，这对⽤⼾来说体验是⾮常不好的。 其次，Web应⽤还缺少了消息推送的能⼒，因为作为⼀个App⼚商，需要有将消息送达到应⽤的能⼒。 最后，Web应⽤缺少⼀级⼊⼝，也就是将Web应⽤安装到桌⾯，在需要的时候直接从桌⾯打开Web应 ⽤，⽽不是每次都需要通过浏览器来打开。

为了避免JavaScript过多占⽤⻚⾯主线程时⻓的情况，浏览器实现了Web Worker的功能。Web Worker的⽬ 的是让JavaScript能够运⾏在⻚⾯主线程之外，不过由于Web Worker中是没有当前⻚⾯的DOM环境的，所 以在Web Worker中只能执⾏⼀些和DOM⽆关的JavaScript脚本，并通过postMessage⽅法将执⾏的结果返 回给主线程。所以说在Chrome中， Web Worker其实就是在渲染进程中开启的⼀个新线程，它的⽣命周期 是和⻚⾯关联的。

**“让其运⾏在主线程之外”**就是Service Worker来⾃Web Worker的⼀个核⼼思想。不过Web Worker是临 时的，每次JavaScript脚本执⾏完成之后都会退出，执⾏结果也不能保存下来，如果下次还有同样的操作， 就还得重新来⼀遍。所以Service Worker需要在Web Worker的基础之上加上储存功能。

另外，由于Service Worker还需要会为多个⻚⾯提供服务，所以还定**不能把Service Worker和单个⻚⾯绑**起来。在⽬前的Chrome架构中，Service Worker是运⾏在浏览器进程中的，因为浏览器进程⽣命周期是最 ⻓的，所以在浏览器的⽣命周期内，能够为所有的⻚⾯提供服务。

2. 消息推送

**消息推送也是基于Service Worker来实现的。**因为消息推送时，浏览器⻚⾯也许并没有启动，这时就需要Service Worker来接收服务器推送的消息，并将消息通过⼀定⽅式展⽰给⽤⼾。关于消息推送的细节这⾥我们就不详述了，如果你感兴趣的话可以⾃⾏搜索相关资料去学习。

3. 安全

基于Web应⽤的业务越来越多了，其安全问题是不可忽视的，所以在设计Service Worker之初，安全问题就被提上了⽇程。

关于安全，其中最为核⼼的⼀条就是HTTP。我们知道，HTTP采⽤的是明⽂传输信息，存在被窃听、被篡改 和被劫持的⻛险，在项⽬中使⽤HTTP来传输数据⽆疑是“裸奔”。所以在设计之初，就考虑对Service Worker采⽤HTTPS协议，因为采⽤HTTPS 的通信数据都是经过加密的，即便拦截了数据，也⽆法破解数据 内容，⽽且HTTPS还有校验机制，通信双⽅很容易知道数据是否被篡改。关于HTTPS协议，我们会在最后 的安全模块详细介绍。

所以要使站点⽀持Service Worker，⾸先必要的⼀步就是要将站点升级到HTTPS。除了必须要使⽤HTTPS，Service Worker还需要同时⽀持Web⻚⾯默认的安全策略、储⼊同源策略、内容安全策略（CSP）等，关于这些，后续我们也会详细介绍。