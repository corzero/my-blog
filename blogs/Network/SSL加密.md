---
title: SSL加密
date: 2021-06-13
tags:
  - Https
categories:
  - Network
---

## 前言

web 的高速发展往往伴随着未知的危险，特别是信息安全。不过目前我们访问的绝大多数网站因为使用了 HTTPS 都具有很强的安全保障，那么为什么 HTTPS 可以帮助我们保障信息安全呢，借此机会了解一下 HTTPS。

## 数据传输

起初设计 HTTP 协议的⽬的很单纯，就是为了传输超⽂本⽂件，那时候也没有太强的加密传输的数据需求，所以 HTTP ⼀直保持着明⽂传输数据的特征。但这样的话，在传输过程中的每⼀个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间⼈，在通信过程中的⼀切内容都在中间⼈的掌握中，如下图：

<img :src="$withBase('/image/中间⼈攻击.png')" alt="中间⼈攻击" height="300"/>

从上图可以看出，我们使⽤ HTTP 传输的内容很容易被中间⼈窃取、伪造和篡改，通常我们把这种攻击⽅式称为**中间⼈攻击**。

具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过⽤⼾电脑、WiFi 路由器、运营商和⽬标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。⽐如⽤⼾电脑被⿊客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者⽤⼾⼀不⼩⼼连接上了 WiFi 钓⻥路由器，那么数据也都能被⿊客抓取或篡改。

## 安全层

由于 HTTP 的明⽂传输使得传输过程毫⽆安全性可⾔，且制约了⽹上购物、在线转账等⼀系列场景应⽤，于是倒逼着我们要引⼊加密⽅案。

从 HTTP 协议栈层⾯来看，可以在 TCP 和 HTTP 之间插⼊⼀个安全层，所有经过安全层的数据都会被加密或者解密，可以参考下图：

<img :src="$withBase('/image/https与http.png')" alt="https与http" height="300"/>

从图中可以看出 HTTPS 并⾮是⼀个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核⼼都在安全层，它不会影响到上⾯的 HTTP 协议，也不会影响到下⾯的 TCP/IP，因此要搞清楚 HTTPS 是如何⼯作的，就要弄清楚安全层是怎么⼯作的。

总的来说，安全层有两个主要的职责：**对发起 HTTP 请求的数据进⾏加密操作和对接收到 HTTP 的内容进⾏解密操作。**而安全层最重要的就是加解密，那么是如何加密的呢？

### 第一版：使⽤对称加密

提到加密，最简单的⽅式是使⽤对称加密。所谓**对称加密是指加密和解密都使⽤的是相同的密钥。**

了解了对称加密，下⾯我们就使⽤对称加密来实现第⼀版的 HTTPS。要在两台电脑上加解密同⼀个⽂件，我们⾄少需要知道加解密⽅式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密⽅式和密钥，过程如下所⽰

<img :src="$withBase('/image/使⽤对称加密实现HTTPS.png')" alt="使⽤对称加密实现HTTPS" height="300"/>

通过上图我们可以看出，HTTPS ⾸先要协商加解密⽅式，这个过程就是 HTTPS 建⽴安全连接的过程。为了
让加密的密钥更加难以破解，我们让服务器和客⼾端同时决定密钥，具体过程如下：

- 浏览器发送它所⽀持的加密套件列表和⼀个随机数 client-random，这⾥的加密套件是指加密的⽅法，加密套件列表就是指浏览器能⽀持多少种加密⽅法列表。
- 服务器会从加密套件列表中选取⼀个加密套件，然后还会⽣成⼀个随机数 service-random，并将 ervicerandom 和加密套件列表返回给浏览器。
- 最后浏览器和服务器分别返回确认消息

这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使⽤相同的⽅法将 client-random 和 service-random 混合起来⽣成⼀个密钥 master secret，有了密钥 master secret 和加密套件之后，双⽅就可以进⾏数据的加密传输了。

通过将对称加密应⽤在安全层上，我们实现了第⼀个版本的 HTTPS，虽然这个版本能够很好地⼯作，但是其中传输 client-random 和 service-random 的过程却是明⽂的，这意味着⿊客也可以拿到协商的加密套件和双⽅的随机数，由于利⽤随机数合成密钥的算法是公开的，所以⿊客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么⿊客也就可以使⽤密钥来伪造或篡改数据了。

### 第⼆版：使⽤⾮对称加密

不过⾮对称加密能够解决这个问题，因此接下来其实可以利⽤⾮对称加密来实现第⼆版的 HTTPS，不过在讨论具体的实现之前，先了解一下什么是⾮对称加密。

和对称加密只有⼀个密钥不同，**⾮对称加密算法有 A、B 两把密钥，如果你⽤ A 密钥来加密，那么只能使⽤ B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能⽤ A 密钥来解密**。

在 HTTPS 中，服务器会将其中的⼀个密钥通过明⽂的形式发送给浏览器，我们把这个密钥称为公钥，服务器⾃⼰留下的那个密钥称为私钥。顾名思义，公钥是每个⼈都能获取到的，⽽私钥只有服务器才能知道，不对任何⼈公开。下图是使⽤⾮对称加密改造的 HTTPS 协议：

<img :src="$withBase('/image/⾮对称加密实现HTTPS.png')" alt="⾮对称加密实现HTTPS" height="300"/>

使⽤⾮对称加密的请求流程：

1. 先浏览器还是发送加密套件列表给服务器
2. 服务器会选择⼀个加密套件，不过和对称加密不同的是，使⽤⾮对称加密时服务器上需要有⽤于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使⽤的，因此服务器会将加密套件和公钥⼀道发送给浏览器。
3. 浏览器和服务器返回确认消息。

这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使⽤该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便⿊客截获了数据和公钥，他也是⽆法使⽤公钥来解密数据的。

因此采⽤⾮对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种⽅式依然存在两个严重的问题。

- 第⼀个是⾮对称加密的效率太低。这会严重影响到加解密数据的速度，进⽽影响到⽤⼾打开⻚⾯的速度。

- 第⼆个是⽆法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使⽤公钥来加密，但是服务器端只能采⽤私钥来加密，私钥加密只有公钥能解密，但⿊客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。

### 第三版：对称加密和⾮对称加密搭配使⽤

基于以上两点原因，我们可以在传输数据阶段依然使⽤对称加密，但是对称加密的密钥我们采⽤⾮对称加密来传输。下图就是改造后的版本：

<img :src="$withBase('/image/混合加密实现HTTPS.png')" alt="混合加密实现HTTPS" height="300"/>

整体流程如下：

- ⾸先浏览器向服务器发送对称加密套件列表、⾮对称加密套件列表和随机数 client-random；
- 服务器保存随机数 client-random，选择对称加密和⾮对称加密的套件，然后⽣成随机数 servicerandom，向浏览器发送选择的加密套件、service-random 和公钥；
- 浏览器保存公钥，并利⽤ client-random 和 service-random 计算出来 pre-master，然后利⽤公钥对 premaster 加密，并向服务器发送加密后的数据；
- 最后服务器拿出⾃⼰的私钥，解密出 pre-master 数据，并返回确认消息

到此为⽌，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使⽤这三组随机数⽣成对称密钥，因为服务器和浏览器使⽤同⼀套⽅法来⽣成密钥，所以最终⽣成的密钥也是相同的。有了对称加密的密钥之后，双⽅就可以使⽤对称加密的⽅式来传输数据了。

**由于 pre-master 是经过公钥加密之后传输的，所以⿊客⽆法获取到 pre-master，这样⿊客就⽆法⽣成密钥，也就保证了⿊客⽆法破解传输过程中的数据了。**

## 数字证书

通过对称和⾮对称混合⽅式，我们完美地实现了数据的加密传输。不过这种⽅式依然存在着问题，如果⿊客通过 DNS 劫持将网站的 IP 地址替换成了⿊客的 IP 地址，这样访问的其实是⿊客的服务器了，⿊客就可以在⾃⼰的服务器上实现公钥和私钥，⽽对浏览器来说，它完全不知道现在访问的是个⿊客的站点。所以还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？

为了能够证明“我就是我”，我们需要一个权威机构记录我当前的网站，要使⽤权威机构颁发的证书，能够让别人可以溯源查询到我的 IP。这个权威机构称为**CA（Certificate Authority）**，颁发的证书就称为**数字证书（Digital Certificate)**。

对于浏览器来说，数字证书有两个作⽤：⼀个是通过数字证书向浏览器证明服务器的⾝份，另⼀个是数字证书⾥⾯包含了服务器公钥。

我们再点击地址栏左侧的安全锁-》证书 后，可以看到如下内容：

<img :src="$withBase('/image/HTTPS证书.png')" alt="HTTPS证书" height="300"/>

那么含有数字证书的 HTTPS 的请求流程：

<img :src="$withBase('/image/完整的HTTPS请求流程.png')" alt="完整的HTTPS请求流程" height="300"/>

相较于第三版的 HTTPS 协议，这⾥主要有两点改变：

1. 服务器没有直接返回公钥给浏览器，⽽是返回了数字证书，⽽公钥正是包含在数字证书中的；
2. 在浏览器端多了⼀个证书验证的操作，验证了证书之后，才继续后续流程。

通过引⼊数字证书，我们就实现了服务器的⾝份认证功能，这样即便⿊客伪造了服务器，但是由于证书是没有办法伪造的，所以依然⽆法欺骗⽤⼾。

### 数字证书的申请

- ⾸先网站需要准备⼀套私钥和公钥，私钥留着⾃⼰使⽤；
- 然后网站向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；
- CA 通过线上、线下等多种渠道来验证网站所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；
- 如信息审核通过，CA 会向网站签发认证的数字证书，包含了网站的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明⽂的，同时包含⼀个 CA ⽣成的签名

这样我们就完成了网站数字证书的申请过程。前⾯⼏步都很好理解，不过最后⼀步数字签名的过程还需要解释下：⾸先 CA 使⽤ Hash 函数来计算网站提交的明⽂信息，并得出信息摘要；然后 CA 再使⽤它的私钥对信息摘要进⾏加密，加密后的密⽂就是 CA 颁给网站的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。

### 验证数字证书

有了 CA 签名过的数字证书，当浏览器向网站服务器发出请求时，服务器会返回数字证书给浏览器。

浏览器接收到数字证书之后，会对数字证书进⾏验证。⾸先浏览器读取证书中相关的明⽂信息，采⽤ CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利⽤对应 CA 的公钥解密签名数据，得到信息摘要 B；对⽐信息摘要 A 和信息摘要 B，如果⼀致，则可以确认证书是合法的，即证明了这个服务器是网站的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。

这时候相当于验证了 CA 是谁，但是这个 CA 可能⽐较⼩众，浏览器不知道该不该信任它，然后浏览器会继续 查找给这个 CA 颁发证书的 CA，再以同样的⽅式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信 任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定⾮法。

另外，在申请和使⽤证书的过程中，还需要注意以下三点：

1. 申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；
2. 数字证书最核⼼的是 CA 使⽤它的私钥⽣成的数字签名；
3. 内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们⾃⼰为⾃⼰签名，我们把这称为⾃签名证书。
