---
title: 浏览器缓存
date: 2019-10-21
tags:
  - 缓存
categories:
  - Browser
---

# 前言
有时候在网络环境很差的情况下，访问之前的静态网站，还是丝滑流畅，是我访问的时候网速变好了？换个新的网站访问再试试发现，很慢。那么之前的之前的网站为什么这么快呢？主要是因为**浏览器缓存**，对于一个请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。而浏览器缓存在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。从而提高性能和效率。

先熟悉一下这张图，然后在开始：

<img :src="$withBase('/image/浏览器缓存机制.png')" alt="浏览器缓存机制" />

这篇文章我们主要通过缓存流程，缓存位置及缓存策略来深入了解一下浏览器的缓存机制。

## 1.什么是缓存？

简单来讲，浏览器通过HTTP请求获取到的资源保存在本地，保存在本地的资源一般统称**缓存**。

## 2.为什么需要缓存？

+ 为了降低冗余的数据传输，节省带宽。
+ 为了减少服务器的负担，提升网站性能。
+ 为了加快了客户端加载网页的速度。
+ 为了提供一些离线PWA应用。


## 3.缓存流程（重要）

需要注意，浏览器与服务器通信的方式为应答模式，也就是：**浏览器发送HTTP请求 –> 服务器响应请求 -> 浏览器接收**。那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？其实浏览器第一次请求时先检查本地是否有该缓存且缓存没失效，发现没有缓存或者失效，则向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。

<img :src="$withBase('/image/浏览器缓存流程.png')" alt="浏览器缓存流程"/>

在上图中，经过了两次检查点，**过期策略**和**协商策略**，而这两个检查是浏览器缓存机制中最重要的。我们把第一次检查叫做**强缓存**，第二次检查叫做**协商缓存**。

### **强缓存**

首先在第一个检查的时候是不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：`Cache-Control` 和 `Expires`。  

**Cache-Control(优先)**：HTTP1.1新增的 Header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间。几个比较常用的设置值如下：

|  值     |  作用   |
|  ----  | ----  |
| public <img width=400/>  | 本地和代理服务器均可缓存 |
| private  | 只能被本地缓存 |
| max-age = xxx  | 缓存在xxx秒后过期，然后重新请求 |
| s-max-age = xxx  | 代理服务器的缓存在xxx秒后过期，然后重新请求 |
| no-store  | 本地及代理服务器及后端服务器不缓存任何资源 |
| no-cache  | 本地及代理服务器都可以缓存，但需要到后端服务器验证 |
| no-cache  | 本地及代理服务器都可以缓存，但需要到后端服务器验证 |
| max-stale  | 能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 |
| min-fresh  | 能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 |  


+ **Expires**：HTTP 1.0 时的规范，缓存过期时间，用来指定资源到期的时间，是服务器端时间的 GMT 格式的时间字符串。比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间。通常，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。但是会出现一个很大的问题，那就是由于失效时间是服务器自身时间，所以当服务器与客户端时间有差别时，就会导致缓存混乱。


**对比**

+ `Cache-Control（HTTP1.1）`优先级高于`Expires（HTTP1.0）`。

<br />
<br />

### **协商缓存**

协商缓存就是强缓存失效后，浏览器携带Header内的标识向服务器发送请求，服务器根据Header内的缓存属性再决定是否使用缓存，协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。

+ **Last-Modified && If-Modified-Since**

    浏览器在第一次访问资源时，服务器返回资源的同时，在Response Header中添加 Last-Modified 的 Header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 Header,

    `Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT` 

    浏览器下一次请求这个资源，浏览器检测到有 `Last-Modified ` 这个字段，于是添加 `If-Modified-Since`，值就是 `Last-Modified` 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。

    *但这里有个Bug就是：  

    **1.如果用户手动打开缓存文件，会导致文件（参照右键资源-> 属性 -> 信息）的缓存时间被系统修改。**  

    **2.Last-Modified 是以秒为单位，无法对1s内修改多次的资源准确识别，无法返回正确的资源。**   

    既然文件修改时间也无法准确决定是否缓存，那能不能和webpack打包一样带上Hash值？通过Hash来决定缓存策略？所以在 `HTTP / 1.1` 出现了 `ETag` 和`If-None-Match`

+ **ETag && If-None-Match(优先)**

`Etag` 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，`Etag` 就会重新生成。  

浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 `Etag` 值放到 `request Header` 里的 `If-None-Match` 里，服务器只需要比较客户端传来的 `If-None-Match` 跟自己服务器上该资源的`ETag` 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。   

如果服务器发现 `ETag` 匹配不上，那么直接以常规 `GET 200` 回包形式将新的资源（包括新的`ETag`）发给客户端；如果 `ETag` 是一致的，则直接返回 304 给客户端直接使用本地缓存即可。


**对比**

+ `Etag`是服务器根据文件计算的，所以相比`Last-Modified` 会更加精确。
+ `Last-Modified` 是秒级的，如果文件频繁修改，就无法准确缓存。
+ 服务器在收到这两个内容时优先使用`Etag`

## 缓存位置

1. **Memory Cache（常见）**

    <img :src="$withBase('/image/内存缓存.png')" alt="内存缓存"/>

    `Memory Cache` 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

    内存缓存中有一块重要的缓存资源是`preloader`相关指令（例如``<link rel="prefetch">``）下载的资源。`preloader`是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。

    **注意：**：不是所有资源都存入这里，虽然很快，但内存是系统中最重要的资源，还要留下空间给其他应用。另外，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

2. **Disk Cache（常见）**

    <img :src="$withBase('/image/磁盘缓存.png')" alt="磁盘缓存"/>

    `Disk Cache` 也就是存储在硬盘中的缓存，虽然读取速度慢，但是什么都能存储到磁盘中。在所有浏览器缓存中，`Disk Cache` 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

    **`Memory Cache`和`Disk Cache`, 更多的是在系统资源有限的情况下，优先将影响页面渲染的静态资源缓存到内存中，其他请求资源会放到磁盘中缓存。但系统内存足够多，那么会将部分资源缓存到内存中。**


3. **Service Worker**

    Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

    Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

    当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。


4. **Push Cache**

    Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令，目前涉及到Push Cache的很少，国内现在好像也没怎么听说过这些，有兴趣可以戳右边[Push Cache](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)。


## 特殊的用户行为


<img :src="$withBase('/image/浏览器用户行为缓存.png')" alt="浏览器用户行为缓存"/>



















