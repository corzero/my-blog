---
title: 事件循环机制的理解
date: 2021-05-03
tags:
  - 面试
categories:
  - JS
---

## 什么是事件循环？

在回答这个问题之前，跟我一起回顾一下关于浏览器的一些知识，现代浏览器是多进程多线程的，但对于JS代码而言，但是单线程的，js的执行和渲染是公用的一个线程，这也是我们经常说js执行和渲染是互斥的根本原因。

JavaScript的一大特点就是单线程，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。当然新标准中的web worker涉及到了多线程，我对它了解也不多，这里就不讨论了。

JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列（task queue）来搞定另外一些代码的执行。

而对于多个任务执行，我们其实有很多解决办法：
+ 排队。一个进程上执行一个任务，上个任务完成后执行下个任务。
+ 新建进程。node可使用fork命令，为每个任务新建一个进程。
+ 新建线程。因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。

这些办法在其他的语言中也有用到，但在早期，对于仅仅用来做交互的js代码而言显得太过复杂。所以就摒弃了上述多进程或者多线程的方式。

但在单一的进程上去处理非常多的事情，js单线程、非阻塞的脚本语言，单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务，非阻塞靠的就是 event loop（事件循环）。

## 事件循环如果获取事件？

在用户浏览页面的同时，主进程不仅仅会收到用户的鼠标操作，也可能会收到资源加载完毕、音视频播放等很多事件。也就是说渲染主线程会频繁接收到来⾃于IO线程的⼀些任务，接收到这些任务之后，渲染进程就需要着⼿处理，⽐如接收到资源加载完成的消息后，渲染进程就要着⼿进⾏DOM解析了；接收到⿏标点击的消息后，渲染主线程就要开始执⾏相应的JavaScript脚本来处理该点击事件。

也就是说浏览器的其他线程也会通知主线程，有事情需要处理，那么怎么去管理这些事件呢？ ———— 消息队列

### 消息队列

> 消息队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。

<img :src="$withBase('/image/eventloop-queue.png')" alt="eventloop-queue" height="300"/>

通常我们把队列里的任务叫**宏任务**，但消息队列其实是无法满足我们的需求，因为会有以下两个问题：

1. 无法处理⾼优先级的任务

原因：例如在监控DOM节点的增删改变化时，对应去处理业务逻辑。通用设计是用浏览器提供的API类似MutastionObserve，同步调用，这是典型的观察者模式，但DOM的频繁变化会让当前这个任务执行事件拉长，导致效率下降。

如果将这些DOM变化做成异步的消息事件，会影响到监控的实时性，因为在添加到消息队列的过程中，可能前⾯就有很多任务在排队了。
如果采⽤同步通知的⽅式，又会影响当前任务的执⾏效率。

为了权衡效率和实时性，微任务就被提出来了。**每次循环中，宏任务只执行一个，每个宏任务中都包含了⼀个微任务队列，因为可能会创建多个微任务，每个循环中的微任务必须执行完**，在执⾏宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执⾏，因此也就解决了执⾏效率的问题。


2. 无法解决单个任务执⾏时⻓过久的问题

原因：因为所有的任务都是在单线程中执⾏的，所以**每次只能执⾏⼀个任务**，⽽其他任务就都处于等待状态。如果其中⼀个任务执⾏时间过久，那么下⼀个任务就要等待很⻓时间，比如js代码执行太久阻碍后面的渲染，那么对用户而言就是非常直观的卡顿现象。


### 这些任务从哪里来呢？

任务一定是有来源的，我们说了因为JS执行和渲染是互斥的，所以首先可以明确一点就是js的执行也算任务，而js的执行来源于事件的驱动，不仅仅是用户的，也可能是来着网络的，如图

<img :src="$withBase('/image/loop-circuit.png')" alt="loop-circuit" height="300"/>


## 任务有哪些类型呢？

在上一个图中我们看到了在主线程中一直是从队列中去获取任务处理的，现在我们把循环的图放大再看。

<img :src="$withBase('/image/loop-circle.png')" alt="loop-circle" height="300"/>

在这个循环内主要有几个模块
+ 宏任务（以前叫macro-task，新标准叫Task）
+ 微任务 (以前叫micro-task，新标准叫Job)
+ RAF （requestAnimationFrame）
+ Style（样式计算）
+ Layout （布局）
+ Paint （绘制）

### 哪些属于宏任务？
script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering

### 哪些属于微任务？
process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)

## 特别注意
1. setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。

```js
// setTimeout中的回调函数才是进入任务队列的任务
setTimeout(function() {
    console.log('xxxx');
})
// 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：
// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行
```
2. 每次的事件循环中，宏任务执行一个，宏任务有可能会创建多个微任务，在当次循环内创建的微任务必须执行完成。
<img :src="$withBase('/image/loop流程图.png')" alt="loop流程图" height="300"/>

## 测试

先看这段代码

```js
console.log(1)
setTimeout(function callback(){
  console.log(2)
})
new Promise((resolve,reject)=>{
  console.log(3)
  resolve()
})
.then(res=>{
  console.log(4)
})
console.log(5)
```

我们照着loop图，梳理一下逻辑，其实整个打印流程就很容易理解了
1. js代码块是宏任务，所以先执行整个代码块
2. console.log(1)是同步任务，直接执行
3. setTimeout属于宏任务，所以我们把这个任务放到下一次循环中执行
4. new Promise实例化是同步的所以执行console.log(3),reslove()
5. 有then任务，这是属于微任务，所以我们放到微任务队列中
6. console.log(5)同步任务，直接执行
7. 此时这个循环的宏任务执行完成了，我们要检查一下还有没有微任务，发现一个console.log(4)
8. 执行console.log(4), 微任务执行完毕，进入下一次循环
9. 消息队列中还有一个console.log(2), 执行

所以整体代码执行打印后结果为： 1 3 5 4 2

<img :src="$withBase('/image/loop-test.awebp')" alt="代码结果" height="300"/>